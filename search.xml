<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jvm学习思维导图</title>
    <url>/2021/02/24/jvm%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="/2021/02/24/jvm%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/ClassLoader.png" alt="ClassLoader"></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）JOIN语句是怎么执行的</title>
    <url>/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一图读懂mysql JOIN语句的执行流程和优化策略。</p>
<a id="more"></a>

<p><img src="/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84.png" alt="JOIN语句是怎么执行的"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm调优</title>
    <url>/2021/03/03/jvm%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h5 id="基本工具介绍"><a href="#基本工具介绍" class="headerlink" title="基本工具介绍"></a>基本工具介绍</h5><ul>
<li><p>jmap</p>
<ul>
<li>jmap -histo pid &gt; file_path：导出内存信息到文件。</li>
<li>jmap-dump 导出当前堆dump</li>
</ul>
</li>
<li><p>jstack</p>
<ul>
<li>jstack pid查看进程是否死锁。</li>
</ul>
</li>
<li><p>jinfo</p>
<ul>
<li>jifo -flags 查看jvm的运行参数。</li>
</ul>
</li>
<li><p><font color="red">jstat</font></p>
<ul>
<li><font color="red">jstat -gc pid &lt;ms&gt; &lt;次数&gt; ：按指定时间打印GC日志。 </font><ul>
<li>S0C:第一个幸存区的大小，单位KB 。</li>
<li>S1C:第二个幸存区的大小 。</li>
<li>S0U:第一个幸存区的使用大小。</li>
<li>S1U:第二个幸存区的使用大小。</li>
<li>EC:伊甸园区的大小。</li>
<li>EU:伊甸园区的使用大小。</li>
<li>OC:老年代大小。</li>
<li>OU:老年代使用大小。</li>
<li>MC:方法区大小(元空间)。</li>
<li> MU:方法区使用大小。</li>
<li>CCSC:压缩类空间大小。</li>
<li>CCSU:压缩类空间使用大小。</li>
<li>YGC:年轻代垃圾回收次数。</li>
<li>YGCT:年轻代垃圾回收消耗时间，单位s。</li>
<li>FGC:老年代垃圾回收次数。</li>
<li>FGCT:老年代垃圾回收消耗时间，单位s。</li>
<li>GCT:垃圾回收消耗总时间，单位s。</li>
</ul>
</li>
</ul>
</li>
<li><p>JVM运行情况预估</p>
<ul>
<li>用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的 JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</li>
<li>年轻代对象增长的速率<br> 可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</li>
<li>Young GC的触发频率和每次耗时<br> 知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。</li>
<li>每次Young GC后有多少对象存活和进入老年代<br> 这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden， survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次 Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。</li>
<li>Full GC的触发频率和每次耗时<br> 知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</li>
</ul>
</li>
<li><p>jvm优化思路</p>
<ul>
<li>jvm动态年龄判断机制<ul>
<li>尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm垃圾收集器</title>
    <url>/2021/02/26/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p><img src="/2021/02/26/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="jvm垃圾收集器"></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）order by语句执行原理及优化策略</title>
    <url>/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>mysql的order by 语句执行原理以及如何优化。</p>
<a id="more"></a>

<p><img src="/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/1.png" alt="order by是怎么工作的？"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我建立了索引，却还是这么慢？</title>
    <url>/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>针对这种疑问，有以下两种情况：</p>
<ol>
<li><strong>优化器没有使用索引。</strong></li>
<li><strong>查询写的不对。</strong></li>
</ol>
<a id="more"></a>

<hr>
<h6 id="优化器没有使用索引"><a href="#优化器没有使用索引" class="headerlink" title="优化器没有使用索引"></a>优化器没有使用索引</h6><ul>
<li>条件字段的函数操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a，cdate字段均存在普通索引。</span><br><span class="line">-- 执行如下sql：</span><br><span class="line">select count(*) from t where month(cdate) &#x3D; &#39;7&#39;;</span><br><span class="line">select * from t where a+1 &#x3D; 1000;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，字段类型为varhcar(32)</span><br><span class="line">select * from t where a &#x3D; 200;</span><br><span class="line">-- 这个sql，存在两个问题：</span><br><span class="line">-- 1.数据类型的转换规则？</span><br><span class="line">-- 答：执行以下select &quot;10&quot; &gt; 9 如果是将字符串转换为数字，则返回结果应该是1，反之为0。</span><br><span class="line">-- 2.为什么走数据类型转换，就走全表扫描？</span><br><span class="line">-- 如果是字符串转换为数字，则上述sql，在执行之前会被优化器处理为：</span><br><span class="line">select * from t where CAST(a AS signed int) &#x3D; 200;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式字符集转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，编码为utf8mb4</span><br><span class="line">-- 表t1中 a1字段存在普通索引 编码为utf8</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; t2.a</span><br><span class="line">-- 由于utf8mb4是utf8的超集，在执行之前会被优化器处理为：</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; CONVERT(t2.a USING utf8mb4)</span><br><span class="line">-- 结果：explain显示，表t2的type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>NULL值比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a is null;</span><br><span class="line">select * from t where a is not null;</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql在对列构建索引时，单列索引无法存储null值，复合索引无法存储全为null的值，这是因为，NULL值无法比较大小，违反了索引树构建时的有序性原则。同理：用null值比较时，不能走索引，只能全表扫描。</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀模糊的查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a like &#39;%reg&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;%reg%&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;reg%&#39;; -- 不一定走全表扫描，mysql会将（全表扫描）的查询消耗和（索引查询+回表）的查询消耗作比较，从而选择出更优的执行计划。</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器在执行此类查询时，不清楚关键字reg是从索引键值的第几个位置开始，所以会根据数据量大小来选择全索引扫描或者全表扫描。</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="查询写的不对。"><a href="#查询写的不对。" class="headerlink" title="查询写的不对。"></a>查询写的不对。</h6><ul>
<li>不合理的分页语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如下业务场景，表t中，存在id,a,b,c,d,e,f字段，有300万行数据，现在要将每一列的值导出至txt文件。</span><br><span class="line">-- A同学考虑到了两个问题：</span><br><span class="line">-- 1.如果没有索引，将会全表扫描，性能较差，也不能建立union_index(a,b,c,d,e,f)代价太高。</span><br><span class="line">-- 综合考虑后，他选择了列值区分度最高的b字段。</span><br><span class="line">-- 2.300万数据一次性加载到服务端，可能会导致服务端发生OOM，于是他想到了分页。</span><br><span class="line">-- 定义初始的pageNum&#x3D;5000，通过计算得到pageSize&#x3D;60;</span><br><span class="line">-- 执行如下sql:（重点关注查询，循环只是简写，并不符合语法要求）</span><br><span class="line">i int default 0;</span><br><span class="line">	while i &lt; 60 do</span><br><span class="line">		select a,b,c,d,e,f from t limit i*5000,5000;</span><br><span class="line">    set i &#x3D; i + 1;</span><br><span class="line">  end while;</span><br><span class="line">-- A同学发现，尽管加了索引，但随着i值的增大，查询还是变的越来越慢。。。</span><br><span class="line">-- explain结果显示，查询走了b字段的索引。那为什么还是会慢呢？</span><br><span class="line">-- 答案是：</span><br><span class="line">-- mysql在执行上述查询时，要先走索引b，一行一行的回表查出a,b,c,d,e,f，然后放弃掉小于i*5000的行。</span><br><span class="line">-- 这会随着i值的增大出现严重的性能问题。</span><br><span class="line">-- 优化办法：延迟关联</span><br><span class="line">select a,b,c,d,e,f from t join (select id from t limit i*5000,5000) t2 on t.id &#x3D; t2.id</span><br><span class="line">-- 由于索引树上的每个值都存在对应主键的值，不需要在回表查询，因此t2的每一行直接在索引树上就可以拿到，查询消耗很小。</span><br><span class="line">-- t2表与t表属于主键关联，优化器在计算驱动表和被驱动表时，会优先将小表做驱动表，大表做被驱动表。</span><br><span class="line">-- 优化器预估t表需要扫描至少3000000行，而t2需要扫描只有5000行。</span><br><span class="line">-- 所以选择：t2表是驱动表，t表是被驱动表</span><br><span class="line">-- 上述查询的逻辑是从t2表中取id字段，去t表中查找主键id匹配的行，直接返回结果。</span><br><span class="line">-- 每次循环共计进行一次索引树扫描，扫描t表5000行。</span><br><span class="line">-- 查询自然很快啦~~~</span><br></pre></td></tr></table></figure>

<ul>
<li>关联子查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where t.a in (select a from t2 where t2.b&#x3D;&#39;c&#39;);</span><br><span class="line">-- mysql5.5之前的版本总是会将上述的in语句优化成如下sql</span><br><span class="line">select * from t where exists (select * from t2 where t2.a &#x3D; t.a and t2.b &#x3D; &#39;c&#39;);</span><br><span class="line">-- 首先解释一下in和exists的执行计划上的区别，抛开优化器将in优化成exists这个不谈(因为mysql5.6以后对in的优化策略有变动)。</span><br><span class="line">-- in语句，mysql优化器会先执行in中的subQuery，将返回的结果集做排序。（符合MRR优化），再去做全表扫描或者索引扫描。</span><br><span class="line">-- exists，mysql先从outerQuery取出一行，去subQuery做等值查询，如此循环直到outQuery循环完最后一行。</span><br><span class="line">-- exists和in的查询效率相同吗？得分情况讨论。</span><br><span class="line">-- t表是大表 t2是小表  in 更快</span><br><span class="line">-- t表时小表 t2是大表  exists 更快</span><br><span class="line">-- 所以在上述任何一个query返回比较慢的时候，决定优化query前，先考虑两张表在业务上，哪张表的数据量较大。</span><br><span class="line">-- 或者选用join来改写上述query，mysql优化器会正确预估驱动表和被驱动表(但需要确定改写成join后不会返回额外的重复记录)。</span><br><span class="line">select t.* from t join t2 on t.a &#x3D; t2.a where t2.b &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>从JDK源码级别剖析类加载过程-笔记</title>
    <url>/2021/01/20/%E4%BB%8EJDK%E6%BA%90%E7%A0%81%E7%BA%A7%E5%88%AB%E5%89%96%E6%9E%90%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h5><ul>
<li>将类的字节码文件加载到内存整个过程：<ul>
<li>验证：校验字节码文件的正确性。</li>
<li>准备：给类的静态变量分配内存，并赋予初始值。</li>
<li>解析：<ul>
<li>将符号引用替换为直接引用：将一些静态方法（符号引用）转换为加载到内存中的地址（直接引用）</li>
<li>动态链接：非静态方法：初始化时并不会转换地址，只有代码运行到这一行时，才会解析这一行代码的符号引用，转换为加载到内存的地址。</li>
</ul>
</li>
<li>初始化：对类的静态变量初始化为指定的值，执行静态代码块。</li>
</ul>
</li>
</ul>
<h5 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h5><ul>
<li><p>java有哪些类加载器：</p>
<ul>
<li><p>引导类加载器（BootstrapClassLoader）：加载java的lib包下的类</p>
</li>
<li><p>扩展类加载器（ExtClassLoader）：加载java的ext包下的类</p>
</li>
<li><p>应用程序类加载器（AppClassLoader）加载应用程序的lib和应用程序本身的类。</p>
<p>上述类加载器是由高到底排序的。</p>
</li>
</ul>
</li>
<li><p>什么是双亲委派机制：</p>
<ul>
<li>当需要加载一个类时，会优先委托父类加载器在其相应的目录下尝试加载此类，如果没有加载到，则继续委托上层类加载器进行加载，如果上层类加载器还是没有加载到，则会向下委托，如果委托到最底层类加载器还没有加载到，则会抛出ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h5 id="实现自定义的类加载器并打破双亲委派机制"><a href="#实现自定义的类加载器并打破双亲委派机制" class="headerlink" title="实现自定义的类加载器并打破双亲委派机制"></a>实现自定义的类加载器并打破双亲委派机制</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoaderTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将类文件以字节码的形式读入内存</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> packagePath</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadData(String packagePath)&#123;</span><br><span class="line">            packagePath = packagePath.replaceAll(<span class="string">&quot;\\.&quot;</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.classPath+File.separator+packagePath+<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">                <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</span><br><span class="line">                fis.read(array);</span><br><span class="line">                fis.close();</span><br><span class="line">                <span class="keyword">return</span> array;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义类加载器-继承ClassLoader类实现findClass方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String packagePath) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] array = loadData(packagePath);</span><br><span class="line">            <span class="keyword">if</span>(array != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(packagePath, array, <span class="number">0</span>, array.length);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现loadClass方法-打破双亲委派机制</span></span><br><span class="line"><span class="comment">         * 为什么要打破双亲委派机制？哪里使用到了双亲委派机制</span></span><br><span class="line"><span class="comment">         * Tomcat打破了双亲委派机制，就是为了满足不同war加载spring版本不同时，实现war包之间类文件的隔离性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//jdk8双亲委派机制源码</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        //判断自己是否存在父类加载器</span></span><br><span class="line"><span class="comment">//                        if (parent != null) &#123;</span></span><br><span class="line"><span class="comment">//                            c = parent.loadClass(name, false);</span></span><br><span class="line"><span class="comment">//                        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                            //到达顶级，引导类加载器</span></span><br><span class="line"><span class="comment">//                            c = findBootstrapClassOrNull(name);</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"><span class="comment">//                    &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">//                        // ClassNotFoundException thrown if class not found</span></span><br><span class="line"><span class="comment">//                        // from the non-null parent class loader</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                        <span class="comment">// to find the class.</span></span><br><span class="line">                        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                        <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;day01&quot;</span>))&#123;</span><br><span class="line">                            c = findClass(name);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">&quot;/Users/alualu/Desktop/learning&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            Class clazz = customClassLoader.findClass(&quot;day01.User&quot;);</span></span><br><span class="line">                Class clazz = customClassLoader.loadClass(<span class="string">&quot;day01.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Object obj = clazz.newInstance();</span><br><span class="line">                Method method = clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">                method.invoke(obj);</span><br><span class="line">                System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm对象创建与内存分配机制分析</title>
    <url>/2021/02/23/jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h5 id="jvm对象创建过程"><a href="#jvm对象创建过程" class="headerlink" title="jvm对象创建过程"></a>jvm对象创建过程</h5><ul>
<li>类加载检查<ul>
<li>当java虚拟机执行到字节码遇到new关键字时，首先检查该关键字对应的参数是否在常量池中存在类的符号引用（即类的全路径名称）并且检查该类是否被类加载器加载过，如果没有，则需要执行类加载过程。</li>
</ul>
</li>
<li>分配内存<ul>
<li>方式<ul>
<li>指针碰撞：假定当前jvm的内存区域是规整的，则内存分配的方式是将指针由非空闲区域向空闲区域移动对象所占内存大小的距离。</li>
<li>空闲列表：如果当前jvm内存区域是不规整的，则jvm会维护一张表，用于记录实际的内存分配情况，从内存中找出一块足够大的区域，分配给该对象。</li>
</ul>
</li>
<li>并发问题<ul>
<li>CAS(Compare and Swap)失败重试：虚拟机采用CAS保证对象分配和更新操作的原子性。</li>
<li>本地线程分配缓冲：为每个线程分配指定步长的地址空间，用于线程内部的对象分配。</li>
</ul>
</li>
</ul>
</li>
<li>初始化<ul>
<li>将对象中的数据类型都初始化为0值。</li>
</ul>
</li>
<li>设置对象头<ul>
<li>对象头的信息包含，这个对象是哪个类的实例，如何找到该对象的类的元数据信息（在方法区），以及对象的GC分代年龄等。</li>
</ul>
</li>
<li>调用Class.init() 根据传入的参数给对象赋值。</li>
<li>在栈中创建该对象的引用，指向堆区的实例。</li>
</ul>
<h5 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h5><p>一般情况下对象是直接分配在堆区的。</p>
<ul>
<li><p>栈上分配？</p>
<ul>
<li><p>逃逸分析：jvm会对方法内部的对象做逃逸分析，如果方法中的对象作用范围仅在当前方法中且对象大小合适（jvm分析栈帧中可以放的下），则该对象是优先存放在栈中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈上分配示例，不逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  user.setName(<span class="string">&quot;lulu&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆区分配，逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  user.setName(<span class="string">&quot;lulu&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标量替换：对象在栈上分配时，会将该对象的成员变量分解成方法的局部变量供此方法使用。</p>
</li>
</ul>
</li>
<li><p>堆区分配</p>
<ul>
<li>Eden区：大多数情况下，对象是直接分配在Eden区，当Eden区不够放时，会触发一次minor GC，扫描Eden区和非空的survivor区。通过可达性分析算法，判断当前对象是否可以被回收，然后将两者中不可回收的对象放到一块为空的survivor区，并将其GC分代年龄+1，然后将标记的垃圾对象干掉。</li>
<li>老年代：<ul>
<li>大对象直接进入老年代。</li>
<li>长期存活的对象进入老年代。</li>
<li>对象的动态年龄判断：<ul>
<li>触发minor GC时，jvm在将不可回收的对象（年龄1+…+年龄n）放到一块为空的survivor区前，会判断这些对象是否大于survivor区的50%，如果大于，则大于年龄n的对象会直接进入老年代。</li>
</ul>
</li>
<li>老年代空间分配担保机制。<ul>
<li>年轻代每次minior GC之前jvm都会计算老年代的剩余空间，如果可用空间大于年轻代里所有对象大小之和，则正常触发minior GC，反之触发full GC，将老年代和年轻代一起回收，如果触发full GC之后还是没有足够的空间存放新的对象，则会抛出OOM异常。</li>
<li>如果触发完minior GC后老年代还是放不下年轻代的所有对象，依旧会触发full GC，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法-排序</title>
    <url>/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><ul>
<li><p>核心思想：冒泡排序总是比较相邻元素的大小，如果符合比较规则，则将这两个元素对换位置，一次冒泡至少会有一个元素出现在它应该存放的位置。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">         <span class="comment">//提前终止循环标记</span></span><br><span class="line">         <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">             arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">             arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">             flag = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果一趟排序下来没有元素发生交换，则说明待排序的数据已经是有序的了，直接跳出循环</span></span><br><span class="line">         <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ul>
<li>最坏时间复杂度：arr1= [6,5,4,3,2,1,0]，数组中的每一个元素都需要进行数据搬移过程，时间复杂度为O(n²)</li>
<li>最好时间复杂度：arr1 = [0,1,2,3,4,5,6]，数组中不需要任何排序过程，一次循环后，直接被flag跳出，时间复杂度为O(n)。</li>
</ul>
</li>
</ul>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li>核心思想：我们将一个元素插入到一个有序数组中时，如何继续保证数组依然有序呢？我们只需要遍历数组，找到合适的位置插入该数据即可，插入排序便是利用这种思想，它将数据分为<font color="red">已排序区间和未排序区间</font>，初始化时，已排序区间默认有一个元素，然后循环未排序区间的元素，每次取一个未排序元素在已排序区间中找合适的位置插入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insert</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j] &gt; value)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析<ul>
<li>最坏时间复杂度：arr1= [6,5,4,3,2,1,0]，每次比较，相当与在已排序区间的首位置插入一个元素，并将已排序区间的已有元素后移一位，时间复杂度为O(n²)</li>
<li>最好时间复杂度：arr1 = [0,1,2,3,4,5,6]，数组中不需要任何排序过程，内层循环总是被直接break掉，相当与只执行了一次外层循环，时间复杂度为O(n)。</li>
</ul>
</li>
</ul>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><ul>
<li><p>核心思想：选择排序和插入排序很类似，也是分已排序区间和未排序区间，区别是选择排序每次取的是未排序区间的最小元素，放到已排序区间的末尾。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Selection&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])&#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ul>
<li>最好时间复杂度：O(n²)</li>
<li>最坏时间复杂度：O(n²)</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>性能提升利器-查询优化</title>
    <url>/2020/12/02/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%88%A9%E5%99%A8-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>内容概览：<ul>
<li>建立合适的索引</li>
<li>优化关联查询</li>
<li>优化子查询</li>
<li>优化ORDER BY</li>
<li>优化LIMIT</li>
<li>UNION 还是 UNION ALL</li>
<li>优化COUNT</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h5><h6 id="什么情况下应该建立索引"><a href="#什么情况下应该建立索引" class="headerlink" title="什么情况下应该建立索引"></a>什么情况下应该建立索引</h6><ol>
<li><p>首先考虑的是建立索引的成本是否可以接受：因为索引本身会占用一定的磁盘空间，如果mysql数据量特别大，建立索引，对查询的执行效率没有太大的提升，但构建索引会耗费更多的磁盘空间，还会在mysql服务器在执行DML操作时需要额外维护一次索引树，影响DML操作的执行效率，对于数据量特别大的表，建议采用分区表。</p>
</li>
<li><p>好，现在建立索引的成本可以接受了，次要考虑的是，索引列的区分度是否较大，对于一些列（比方说：性别，是否删除），这种区分度不大的列，建立索引其实效果很一般。</p>
</li>
<li><p>在where、join、exists中等值匹配的字段。</p>
</li>
<li><p>order by的字段。（这里没办法一句话讲清楚，详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a>）</p>
</li>
</ol>
<h6 id="该建立什么索引"><a href="#该建立什么索引" class="headerlink" title="该建立什么索引"></a>该建立什么索引</h6><p>上述情况都考虑过后，留给我们的问题就是建立什么样的索引：</p>
<ul>
<li><p>普通索引和唯一索引选哪个？：</p>
</li>
<li><p>详情请见<a href="http://www.alualu.cn/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/#more">普通索引和唯一索引的区别</a></p>
</li>
<li><p>该建立多个普通索引，还是一个联合索引？</p>
<ul>
<li><p>联合索引总是遵循<font color="red">最左前缀原则</font>：即对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where b &#x3D; &#39;123&#39;;  -- 无法使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，可以直接在索引上返回结果<font color="red">（mysql5.6引入的索引下推优化）</font>，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t;  -- 可以使用union_idx_abc(a,b,c)</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，当在这些字段上需要排序时，可以利用索引的有序性特点，直接在索引上返回排序结果，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t order by b; </span><br><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39; order by b;</span><br></pre></td></tr></table></figure>

<p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
</li>
</ul>
</li>
</ul>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/#more">一条JOIN语句时怎么执行的</a></p>
<h6 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h6><ul>
<li><p>in 语句优化</p>
<ul>
<li>in语句子查询会导致外层表无法使用索引。详见<a href="https://www.cnblogs.com/wy123/p/7092194.html"><a href="https://www.cnblogs.com/wy123/p/7092194.html">MySQL中IN子查询会导致无法使用索引</a></a></li>
<li>避免in语句的子查询不会返回过多的结果，否则影响查询效率。</li>
<li>尽量将in转化为join，前提是不会产生笛卡尔积。</li>
</ul>
</li>
<li><p>exists语句优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t where exists (select &#39;x&#39; from t2 where t.a &#x3D; t2.a)</span><br></pre></td></tr></table></figure>

<ul>
<li>当出现查询缓慢时，检查t2表的a字段是否存在索引。</li>
<li>t表数据量大时，尽量不要采取此写法，此查询会对t表进行全表或索引扫描，取出t表的每一行的a字段，与t2表的a字段做等值匹配。</li>
</ul>
</li>
</ul>
<h6 id="优化ORDER-BY"><a href="#优化ORDER-BY" class="headerlink" title="优化ORDER BY"></a>优化ORDER BY</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
<h6 id="优化LIMIT"><a href="#优化LIMIT" class="headerlink" title="优化LIMIT"></a>优化LIMIT</h6><ul>
<li>是否能使用上覆盖索引<ul>
<li>通常情况下，limit语句首先要考虑的是能否使用覆盖索引，而不是查询所有的列。</li>
</ul>
</li>
<li>偏移量很大时，建议采取延迟关联<ul>
<li>详情请见<a href="http://www.alualu.cn/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/#more">为什么我建了索引，却还是那么慢？</a>中不合理的分页语句一栏。</li>
</ul>
</li>
</ul>
<h6 id="UNION-还是UNION-ALL"><a href="#UNION-还是UNION-ALL" class="headerlink" title="UNION 还是UNION ALL?"></a>UNION 还是UNION ALL?</h6><ul>
<li><p>如何优化</p>
<ul>
<li>mysql总是将UNION [ALL]的结果集放入一张临时表中，导致很多优化策略都没办法使用，通常情况下我们需要将where、limit、order by等语句下推到UNON [ALL]的子查询中，以便优化器能充分的利用这些条件来优化查询。</li>
</ul>
</li>
<li><p>UNION和UNION ALL的区别</p>
<ul>
<li>UNION：mysql将UNION左右的查询全部放入一张临时表中，然后使用DISTINCT对临时表做唯一性检查，确保唯一性的情况下将数据行返回给客户端。</li>
<li>UNION ALL ：mysql将UNION左右的查询全部放入一张临时表中，然后返回给客户端。</li>
</ul>
</li>
<li><p>UNION和UNION ALL，我该选哪个？</p>
<ul>
<li>除非客户端需要返回去重的数据，否则一定要使用UNION ALL</li>
</ul>
</li>
</ul>
<h6 id="优化COUNT"><a href="#优化COUNT" class="headerlink" title="优化COUNT"></a>优化COUNT</h6><ul>
<li>COUNT(id)，COUNT(1)，COUNT(字段)，COUNT(*)，我该选哪个？<ul>
<li>COUNT(id)：mysql会遍历整张表，将主键id的值取出来，返回给server层，server判断不可能为空，逐行累加。</li>
<li>COUNT(1)：innodb扫描每一行，但不取值， server对返回的每一行数据，记录一个数字“1”进去，判断数字“1”不可能为空，逐行累加。</li>
<li>COUNT(字段)：如果字段定义not null，mysql遍历整张表，将该字段取出来，判断该字段不可能为null，逐行累加；如果字段定义允许为null，mysql还要额外将<font color="red">字段的值</font>取出来，判断如果不是NULL才累加。</li>
<li>COUNT(<em>)：mysql对COUNT(\</em>)做了专门的优化，*并不是取出表的所有字段，不需要取值，COUNT(*)肯定不是NULL，直接逐行累加。</li>
</ul>
</li>
<li>上述4种COUNT哪个快？<ul>
<li>按执行效率而言，COUNT(*)≈COUNT(1)&gt;COUNT(id)&gt;COUNT(字段)。</li>
<li>如果没有特殊的业务需求，建议采用COUNT(*)。</li>
</ul>
</li>
<li>我采用了COUNT(*)，但表太大还是很慢怎么办？<ul>
<li>建议单独建立计数器表，记录表名和表记录数，执行关于被记录表的DML语句时，在同一个事务内，对该计数器表进行更新（+1 or  -1）。</li>
</ul>
</li>
</ul>
<h6 id="EXPLAIN-详解"><a href="#EXPLAIN-详解" class="headerlink" title="EXPLAIN 详解"></a>EXPLAIN 详解</h6><ul>
<li><p>id列：id列标记的是sql语句的执行顺序，id值越大，越优先执行，id值相同，自上而下顺序执行。</p>
</li>
<li><p>select_type：这一列表示explain结果集的哪一行在访问哪个表。</p>
<ul>
<li>simple：简单查询，整条查询语句中不包含子查询，union。</li>
<li>primary：复杂查询的最外层select。</li>
<li>subquery：包含在select语句中的子查询。</li>
<li>derived：包含在from语句中的子查询，以derivedN（derived+id字段）展示。</li>
<li>union：在union中的第二个和随后的查询</li>
</ul>
</li>
<li><p>type列：这一列表示关联类型或者访问类型：性能依次从最优到最差分别为system&gt;const&gt;eq_ref_ref&gt;range&gt;index&gt;ALL。一般来说得保证查询优化到range级别，最好能到eq_ref。</p>
<ul>
<li><p>NULL：mysql能够在优化阶段分解查询语句，确定出查询不需要访问任何索引或表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- id是主键</span><br><span class="line">explain select min(id) from actor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const：mysql能对查询进行优化，使之成为一个常量，用于访问primary key 和 unique key的列，或者将该列与常数进行比较时。</p>
</li>
<li><p>system：根据primary key 或者 unique key查询的表或者结果集中只有一行记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- id是主键</span><br><span class="line">EXPLAIN select * from (SELECT * FROM actor WHERE id &#x3D; 2) t;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eq_ ref：primary key 或者unique key 被当做连接条件使用，所以只返回一条记录，这是除const之外最好的连接类型了。</p>
</li>
<li><p>ref：相比eq_ref，此连接类型用normal key 或者（unique key、union key） 的部分前缀当做连接条件，所以返回可能有多行。</p>
</li>
<li><p>range：范围扫描，通常出现在in()，between and，&gt;，&lt;，&gt;=，&lt;=等操作中，使用一个索引来检索指定范围的行。</p>
</li>
<li><p>index：从索引上能直接返回结果，一般是扫描某个二级索引，这种扫描不会从跟节点开始扫描，而是直接对二级索引的所有叶子节点进行扫描，速度还是比较慢的，这个查询一般是使用了覆盖索引，但通常情况下二级索引比较小，所以这种类型比ALL更快些。</p>
</li>
<li><p>ALL：即全表扫描，一般是扫描聚簇索引的所有叶子节点，出现这个类型一般情况下，你的sql该优化了。</p>
</li>
</ul>
</li>
<li><p>possible_keys：mysql预估可能要使用的索引名称。</p>
</li>
<li><p>key：mysql实际使用的索引名称</p>
</li>
<li><p>key_len：使用索引的长度，可以使用此字段来确定，使用了联合索引的哪些字段。</p>
<ul>
<li>计算规则如下：<ul>
<li>字符串：<ul>
<li>char(n) ：n字节长度</li>
<li>varchar(n)：如果是utf8 则长度是3n+2字节。加的两字节是用来存储字符串的实际长度。</li>
</ul>
</li>
<li>数值类型：<ul>
<li>tinyint：1字节</li>
<li>smallint：2字节</li>
<li>int：4字节</li>
<li>bigint：8字节</li>
</ul>
</li>
<li>时间类型：<ul>
<li>date：3字节</li>
<li>timestamp：4字节</li>
<li>datetime：8字节</li>
</ul>
</li>
<li>如果字段允许为NULL，则另外需要一个字节来记录该字段是否为NULL</li>
</ul>
</li>
<li>mysql索引的最大长度是768，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符串提取出来做索引。</li>
</ul>
</li>
<li><p>ref：表示索引字段匹配的是常量还是其他表的字段，常见的值有const，或者（db.table.field）。</p>
</li>
<li><p>rows：mysql预估查询扫描的行数，这个值不精确。</p>
</li>
<li><p>extra列：</p>
<ul>
<li>Using index：查询的结果字段使用了覆盖索引。</li>
<li>Using index condition：查询列不被索引完全覆盖且where条件中是索引的前缀。</li>
<li>Using where：查询字段没有使用到索引。</li>
<li>Using where Using index：查询的结果字段使用了覆盖索引，但是where条件中字段没有使用到索引。</li>
<li>Using filesort： 使用了文件排序，mysql在认为需要排序字段+查询列的列定义长度小于max_length_for_sort_data时，默认采取全字段排序，如果data_size&gt;sort_buffer_size（默认2M），mysql将结果集分为n个文件，对每个文件进行排序，再将这n个有序的小文件合并成一个有序的大文件，返回结果集。</li>
<li>Using tempory：查询使用到了临时表，一般出现在union、distinct语句，一般是由于union、distinct的字段没有使用到索引导致的，优化思路是建立合适的索引，使之变为Using index。</li>
<li>Select tables optimized away：使用某些聚合函数来访问存在索引的某个字段，一般不需要优化。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法-数组</title>
    <url>/2020/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<a id="more"></a>

<h6 id="数组的数据结构"><a href="#数组的数据结构" class="headerlink" title="数组的数据结构"></a>数组的数据结构</h6><ul>
<li><p>数组是是一种线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。</p>
</li>
<li><p>数组的特点</p>
<ul>
<li>连续性：在内存中是必须是连续的，如果需要在内存中申请size=100M的数组，如果内存中的连续的内存空间不足100M，会申请失败。</li>
<li>相同类型：数组中仅支持存储基本类型的数据，且一个数组只能存储一个类型的数据。</li>
<li>查找效率：数据支持下标查找，其时间复杂度是O(1)。</li>
</ul>
</li>
<li><p>为什么数组只能支持存储一种类型的数据。</p>
<ul>
<li><p>原因是，数组在内存中是连续的，需要按固定的数据类型字节数来查找其在内存中的数据。如下图，假定起始地址base_address=1000，则数组中元素的在内存中查找公式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i].address = base_address+i*data_type_size</span><br><span class="line"><span class="comment">//其中data_type_size为存储的数据类型所占的字节数，图例中为int，占4个字节。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84-7861521.png" alt="数组"></p>
<ul>
<li><p>低效的插入和删除</p>
<ul>
<li>插入操作<ul>
<li>假定数组长度为n，现在要插入一个数据到数组的第k个元素，则需要将k~n个元素依次顺序向后移动一位。<ul>
<li>最坏时间复杂度：k是数组的第一个元素，在需要将数组的数据全部向后移动一位，时间复杂度为O(n)</li>
<li>最好时间复杂度：k是数组的最后一个元素，则不需要任何数据搬移操作，直接插入，时间复杂度为O(1)。</li>
<li>平均时间复杂度：(1+2+3+…+n)/n=O(n)。</li>
</ul>
</li>
</ul>
</li>
<li>删除操作<ul>
<li>跟插入操作的时间复杂度一样，不过删除操作可以优化。</li>
<li>优化思路：CPU的标记清除垃圾回收算法。<ul>
<li>需要删除a中的数据时，只是将a中需要删除的数据单独记录在一个独立的空间里，当数组没有更多的空间存储数据时，再将其中的内容一次性的删除，这样就减少了很多次的数据搬移操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList是否能完全代替Array？</p>
<ul>
<li><p>在java中，ArrayList最大的优势就是将插入，删除等操作封装起来，另外，它还支持<font color="red">动态扩容</font>。</p>
<ul>
<li><p>动态扩容：假定初始我们定义了一个长度为10的ArrayList，当插入第11个元素时，ArrayList会自动申请一个1.5倍大小的新的ArrayList，再将当前数据copy过去，这在ArrayList数据量大时，是非常浪费时间和空间的，在预先知道要存储多少数据时，建议初始化申请就申请定长的ArrayList，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-链表</title>
    <url>/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><h6 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h6><ul>
<li><p>链表是将一组零散的内存空间通过链式数据结构存储起来，与数组不同的是，链表不需要连续的内存空间，他是通过一组指针将零散的内存块连续起来使用，假定内存中连续的内存空间不足100mb，我们申请100mb大小的链表是完全不会有问题的。</p>
<a id="more"></a>

</li>
</ul>
<h6 id="常用的链表"><a href="#常用的链表" class="headerlink" title="常用的链表"></a>常用的链表</h6><ul>
<li>常用的链表有：单链表、双向链表、循环链表<ul>
<li>单链表：单链表的节点除了存储当前节点的data外，还需要存储下一节点的地址，故单链表中，所有的节点只知道自己下一个节点是谁，尾结点的下一节点为null，。</li>
<li>双向链表：与单链表不同的是，双向链表除了存储下一节点的地址外，还存储了其上一节点的地址。头结点的上一节点、尾节点的下一节点都是null。</li>
<li>循环链表：循环链表较上述两个链表的区别是，循环链表将尾结点的下一节点指针，指向了头结点。</li>
</ul>
</li>
</ul>
<h5 id="java实现单链表"><a href="#java实现单链表" class="headerlink" title="java实现单链表"></a>java实现单链表</h5><h6 id="节点实现类"><a href="#节点实现类" class="headerlink" title="节点实现类"></a>节点实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一节点的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; nextNode;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node&lt;T&gt; nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写equals，便于接下来的对象比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj || <span class="keyword">this</span>.getData().equals(((Node)obj).getData())) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="单链表实现类"><a href="#单链表实现类" class="headerlink" title="单链表实现类"></a>单链表实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的实现类：</span></span><br><span class="line"><span class="comment"> * 单链表特性：</span></span><br><span class="line"><span class="comment"> * 每个节点只知道自己下一个节点是谁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; headNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从尾节点开始插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node p = headNode;</span><br><span class="line">            <span class="keyword">while</span> (p.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p = p.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">            p.setNextNode(nextNode);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从头结点插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToFirstNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明已有节点在head,需要让新节点的下一节点指向当前你head节点，再将新节点赋值给head节点。</span></span><br><span class="line">            nextNode.setNextNode(headNode);</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据下标获取链表中的节点元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index &gt; getSize()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; node = headNode.getNextNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == index - <span class="number">1</span>)&#123;</span><br><span class="line">                node = node.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;&#123;\&quot;curr\&quot;:\&quot;&quot;</span>+p.getData()+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;next\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> ? p.getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.substring(<span class="number">0</span>,stringBuffer.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据节点删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByNode</span><span class="params">(Node&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; headNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果待删除的节点是头结点，直接将头结点的下一节点赋值给头结点，就实现了节点删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(p == headNode)&#123;</span><br><span class="line">            headNode = headNode.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果不是头节点，则从当前链表的头结点开始顺序查找下一节点，直到等于待删除的节点为止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;T&gt; q = headNode;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span> &amp;&amp; ! q.getNextNode().equals(p))&#123;</span><br><span class="line">            q = q.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果q为null，说明没有匹配的待删除的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  匹配到，将当前q节点的下一节点指向下下一个节点，就实现了节点删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        q.setNextNode(q.getNextNode().getNextNode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据节点数据删除（删除多节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByData</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(headNode.getData().equals(data))&#123;</span><br><span class="line">            headNode = headNode.getNextNode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果不是头节点，则从当前链表的头结点开始顺序查找下一节点，直到等于待删除的节点为止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt; q = headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.getNextNode().getData().equals(data))&#123;</span><br><span class="line">                q.setNextNode(q.getNextNode().getNextNode());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleLinkList&lt;String&gt; singleLinkList = <span class="keyword">new</span> SingleLinkList&lt;String&gt;();</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        singleLinkList.addToFirstNode(<span class="string">&quot;000&quot;</span>);</span><br><span class="line">        Node&lt;String&gt; delNode = <span class="keyword">new</span> Node&lt;String&gt;();</span><br><span class="line">        delNode.setData(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        singleLinkList.deleteByNode(delNode);</span><br><span class="line">        singleLinkList.deleteByData(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="基于单链表实现LRU算法"><a href="#基于单链表实现LRU算法" class="headerlink" title="基于单链表实现LRU算法"></a>基于单链表实现LRU算法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> day01.singleLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于链表实现LRU缓存失效算法</span></span><br><span class="line"><span class="comment"> * 即固定的链表大小中，最多次访问的排在最前面，超出链表大小后淘汰最后面的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> alualu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; headNode;</span><br><span class="line">    <span class="comment">//缓存总容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//当前缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = DEFAULT_CAPACITY;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedList</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据data找链表中匹配节点的前一个节点，</span></span><br><span class="line"><span class="comment">     * 后续要通过此节点来执行节点删除操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">findPreNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;T&gt; p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.equals(p.getNextNode().getData()))&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟缓存入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断缓存中是否已经存在此数据</span></span><br><span class="line">        Node&lt;T&gt; p = findPreNode(data);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将此数据从链表中删除</span></span><br><span class="line">            deleteByPreNode(p);</span><br><span class="line">            <span class="comment">//重新插入链表头部</span></span><br><span class="line">            addToFirstNode(data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//判断加入数据后是否超出capacity</span></span><br><span class="line">            <span class="keyword">int</span> postSize = size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(postSize &gt; capacity)&#123;</span><br><span class="line">              <span class="comment">//需要删除最后一个节点，再加入新的节点</span></span><br><span class="line">                deleteLastNode();</span><br><span class="line">                addToFirstNode(data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//直接加入新的节点</span></span><br><span class="line">                addToFirstNode(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByPreNode</span><span class="params">(Node&lt;T&gt; preNode)</span></span>&#123;</span><br><span class="line">        preNode.setNextNode(preNode.getNextNode().getNextNode());</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteLastNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p.getNextNode().getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p.setNextNode(<span class="keyword">null</span>);</span><br><span class="line">        size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从头结点插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToFirstNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明已有节点在head,需要让新节点的下一节点指向当前你head节点，再将新节点赋值给head节点。</span></span><br><span class="line">            nextNode.setNextNode(headNode);</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;&#123;\&quot;curr\&quot;:\&quot;&quot;</span>+p.getData()+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;next\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> ? p.getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.substring(<span class="number">0</span>,stringBuffer.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化缓存列表</span></span><br><span class="line">        LRULinkedList&lt;String&gt; lruLinkedList = <span class="keyword">new</span> LRULinkedList&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//模拟入栈操作</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;000&quot;</span>);</span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        <span class="comment">//模拟缓存入栈时，缓存清除策略</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        <span class="comment">//模拟缓存入栈时命中已有缓存。</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        System.out.println(lruLinkedList.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="java实现双向链表"><a href="#java实现双向链表" class="headerlink" title="java实现双向链表"></a>java实现双向链表</h5><h6 id="节点实现类-1"><a href="#节点实现类-1" class="headerlink" title="节点实现类"></a>节点实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> day01.TwowayLinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表-节点的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//上一节点的指针</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; prevNode;</span><br><span class="line">    <span class="comment">//下一节点指针</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; nextNode;</span><br><span class="line">    <span class="comment">//当前节点数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getPrevNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prevNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrevNode</span><span class="params">(Node&lt;T&gt; prevNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prevNode = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node&lt;T&gt; nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写equals，便于接下来的对象比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj || <span class="keyword">this</span>.getData().equals(((Node)obj).getData())) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="双向链表实现类"><a href="#双向链表实现类" class="headerlink" title="双向链表实现类"></a>双向链表实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> day01.TwowayLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表的实现类</span></span><br><span class="line"><span class="comment"> * 双向链表的特性：</span></span><br><span class="line"><span class="comment"> * 每个节点知道自己上一节点和下一节点是谁。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> alualu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwowayLinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; headNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从尾节点插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">       Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">       node.setData(data);</span><br><span class="line">      <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">          Node p = headNode;</span><br><span class="line">          <span class="keyword">while</span> (p.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">          &#125;</span><br><span class="line">          p.setNextNode(node);</span><br><span class="line">          node.setPrevNode(p);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          headNode = node;</span><br><span class="line">      &#125;</span><br><span class="line">      size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入到头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToFirstNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        node.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.setNextNode(headNode);</span><br><span class="line">            headNode.setPrevNode(node);</span><br><span class="line">            headNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;&#123;\&quot;prev\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> &amp;&amp; p.getPrevNode() != <span class="keyword">null</span> ? p.getPrevNode().getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;curr\&quot;:\&quot;&quot;</span>+p.getData()+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;next\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> ? p.getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.substring(<span class="number">0</span>,stringBuffer.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwowayLinkedList twowayLinkedList = <span class="keyword">new</span> TwowayLinkedList();</span><br><span class="line">        twowayLinkedList.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        twowayLinkedList.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        twowayLinkedList.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        twowayLinkedList.printAll();</span><br><span class="line">        twowayLinkedList.addToFirstNode(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        twowayLinkedList.addToFirstNode(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        twowayLinkedList.addToFirstNode(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        twowayLinkedList.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>重要的日志模块，redolog和binlog</title>
    <url>/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/</url>
    <content><![CDATA[<ul>
<li>内容概览：<ul>
<li>更新语句的执行流程</li>
<li>什么是redolog，什么是binlog</li>
<li>什么是两阶段提交</li>
<li>为什么需要两阶段提交</li>
<li>redolog和change buffer的区别</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/911607253188_.pic.jpg" alt="9116072" style="zoom:0%;">

<ul>
<li>连接器<ul>
<li>客户端发出连接请求时，mysql连接器做身份认证，权限查询，并且会将本次权限查询的结果记录起来，应用于此次连接的整个过程，直到连接被终止，<font color="red">所以，mysql修改用户权限时需要重新登录。</font></li>
</ul>
</li>
<li>查询缓存<ul>
<li>mysql会将历史查询的结果以key-value的形式缓存在内存中，key便是查询语句，判断查询缓存是否成功匹配的方式是将本次执行的sql与key进行强关联，sql语句中任何字符，例如空格，换行不匹配都会导致缓存未命中，<font color="red">执行表的更新语句时，会将该表的查询缓存全部清空。</font></li>
<li>一般情况下，查询缓存的命中率非常低，很可能费劲的将查询缓存起来，却被一条更新语句全部清空了，并且缓存清空的过程会持有全局锁，任何跟此缓存有关的查询都需要等待这个锁的释放。</li>
</ul>
</li>
<li>分析器<ul>
<li>进行词法分析，语法分析，将sql语句解析成语法树。</li>
</ul>
</li>
<li>优化器<ul>
<li>优化查询语句，包括调整JOIN语句的关联顺序、索引选择、覆盖索引扫描、提前终止查询等操作，生成执行计划交给执行器。</li>
</ul>
</li>
<li>执行器<ul>
<li>执行优化器提供的语句，如果上述的更新语句，mysql会将此更新做了什么改动记录在redo log里面，并生成此记录的binlog，一起写入磁盘。</li>
</ul>
</li>
</ul>
<h5 id="什么是redolog"><a href="#什么是redolog" class="headerlink" title="什么是redolog?"></a>什么是redolog?</h5><ul>
<li><p>摘自极客时间《MYSQL实战45讲：一条更新语句时如何执行的？》</p>
</li>
<li><p>“粉板”的案例</p>
<p>​        酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。<br>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li><p>直接把账本翻出来，把这次赊的账加上去或者扣除掉；</p>
</li>
<li><p>先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p>
</li>
</ul>
<p>​      在生意很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。<br>​      同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
</li>
<li><p>这个粉板其实就是redo log，<font color="red">数据写入redo log中，状态便更新为prepare，表示随时可以commit</font>。</p>
</li>
<li><p>粉板和账本配合的过程其实就是mysql的WAL（write ahead logging）机制，他的关键点是先写日志，等不忙的时候再更新到磁盘。</p>
</li>
<li><p>假如粉板写满了，也就是下图中wirte pos和checkpoint重合时，mysql就不得不停下DML操作，将redolog上的操作写入磁盘再记录到binlog，同时将checkout point向前推进。</p>
</li>
</ul>
<p><img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/921607253189_.pic.jpg" alt="921607253189_.pic"></p>
<h5 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a>什么是binlog</h5><ul>
<li><p>binlog是mysql server层特有的日志系统，称为mysql的归档日志，采用“追加写”的方式来记录操作日志。</p>
</li>
<li><p>binlog有固定的大小，超过这个大小会新启一个binglog文件来记录。</p>
</li>
<li><p>binlog记录的是逻辑操作，记录的是将username=’lulu’的age修改为16，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><ul>
<li><p>什么是两阶段提交？</p>
<p>mysql将redolog的写入拆分成两个步骤，用不同的状态来标识，一个是prepare状态，另一个是commit状态，这就是两阶段提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行器从username的索引树上查找符合username=’lulu’的记录，回表取出age。</p>
</li>
<li><p>执行器拿到引擎给数据，将值更新为16，再调用接口写入数据。</p>
</li>
<li><p>引擎将这行数据更新到内存中，并将这次的更新操作记录到redolog里面，此时redolog处于prepare状态。</p>
</li>
<li><p>生成此次更新的binlog，并将binlog写入磁盘。</p>
</li>
<li><p>执行器调用事务提交的接口，将刚刚写入的redolog的prepare状态修改为commit状态。</p>
</li>
</ul>
<h5 id="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"><a href="#为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？" class="headerlink" title="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"></a>为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？</h5><ul>
<li><p>首先要解释的一点是：innodb采用redolog，是支持崩溃恢复的。</p>
</li>
<li><p>先写redolog，后写binlog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写redolog，commit。</span><br><span class="line">-- step3: 写binlog。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，此事务的redolog已经记录完成，数据依旧可以从redolog恢复（age=24）。</li>
<li>但由于redolog的状态是commit，mysql不会再触发写入binlog的过程。由于binlog缺失这部分的变更归档，后续使用binlog做数据恢复时lulu依旧是18岁。</li>
</ul>
</li>
</ul>
</li>
<li><p>先写binlog，再写redolog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写binlog。</span><br><span class="line">-- step3: 写redolog，commit。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，由于redolog没有记录变更日志，所以此次事务无效。</li>
<li>但binlog多了这部分的归档，后续使用binlog做数据恢复是lulu变成了24岁。</li>
</ul>
</li>
</ul>
</li>
<li><p>结论：如果不采用两阶段提交，innodb就无法保证，crash之后数据一致性。</p>
</li>
</ul>
<h5 id="redolog和change-buffer的区别"><a href="#redolog和change-buffer的区别" class="headerlink" title="redolog和change buffer的区别"></a>redolog和change buffer的区别</h5><ul>
<li><p>区别一：记录的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- 如果数据在内存中：</span><br><span class="line">-- 此次更新与change buffer无关，</span><br><span class="line">-- redolog会记录以下内容：update(&#39;lulu&#39;,&#39;18&#39;) -&gt; (&#39;lulu&#39;,&#39;24&#39;) to page1</span><br><span class="line">-- 如果数据不在内存中：</span><br><span class="line">-- mysql在内存的buffer pool中生成关于本次操作的change buffer 并记录：我要将username&#x3D;&#39;lulu&#39;的age修改为24.</span><br><span class="line">-- redolog会记录以下内容：new change buffer item[update(&#39;lulu&#39;,&#39;18&#39;) -&gt; (&#39;lulu&#39;,&#39;24&#39;) to page1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别二：崩溃恢复</p>
<ul>
<li>redolog：是实现innodb的crash safe不可或缺的一部分，innodb的崩溃数据恢复主要依赖于redolog。</li>
<li>change buffer：异常崩溃后，change buffer的内容丢失，如果redolog记录了此次change buffer的内容，则可以恢复。如果redolog没记录，说明此次事务没提交就崩溃了。</li>
</ul>
</li>
<li><p>区别三：更新性能上的收益</p>
<ul>
<li>redolog：节省随机写磁盘的IO消耗，转成顺序写。</li>
<li>change buffer：节省随机读盘的IO消耗。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）普通索引和唯一索引的区别</title>
    <url>/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>整理一下mysql普通索引和唯一索引的区别。</p>
<a id="more"></a>

<p><img src="/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB-7577954.png" alt="普通索引和唯一索引的区别"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解MVCC和BufferPool缓存机制</title>
    <url>/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E5%92%8CBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h5 id="mysql的隔离级别"><a href="#mysql的隔离级别" class="headerlink" title="mysql的隔离级别"></a>mysql的隔离级别</h5><ul>
<li>读未提交（Read Uncommited）：一个事务在未提交时，他所作的变更被其他事务查询到。</li>
<li>读提交（Read Commited）：一个事务提交之后，他所作的变更被其他事物查询到。</li>
<li>可重复读（Repeatable Read）：一个事务在执行过程中看到的数据，总是跟这个事务刚启动时看到的数据是一致的。</li>
<li>串行化（Serializable）：对于同一行记录，读会加读锁，写会加写锁，将所有并发执行的事务串行化。</li>
</ul>
<h5 id="mysql默认隔离级别（RR）是如何实现的？"><a href="#mysql默认隔离级别（RR）是如何实现的？" class="headerlink" title="mysql默认隔离级别（RR）是如何实现的？"></a>mysql默认隔离级别（RR）是如何实现的？</h5><h6 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h6><ul>
<li>MVCC（Multi-Version Concurrency Control）：多版本并发控制<ul>
<li>mysql的MVCC就是基于undo日志版本链和事务的一致性视图来完成的。<ul>
<li>undo日志版本链：mysql在更新记录的事务修改完成后，会将更新前的记录到undo log中，同时用两个隐藏字段txn_id和rollback_pointer将这些undo日志串联起来形成版本链，事务回滚时，读取undo log中的数据，实现回滚。</li>
<li>从时刻1起，共有三个事务共进行四次数据变更，其版本链关系如图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E5%92%8CBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/1615039619722-5039662.jpg" alt="1615039619722" style="zoom:50%;">

<ul>
<li><p>read-view（事务一致性视图）</p>
<ul>
<li><p>在可重复读隔离级别下，当事务开启时，执行任何查询sql时会生成当前事务read-view，该视图在事务结束之前都不会变化，这个视图由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id(max_id)组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
</li>
<li><p>上述undilog版本链的read-view如下表格所示。</p>
<table>
<thead>
<tr>
<th align="center">已提交事务</th>
<th align="center">活跃事务(未提交和已提交事务)</th>
<th align="center">未提交事务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">txn_id&lt;100</td>
<td align="center">100&lt;=txn_id&lt;=200</td>
<td align="center">txn_id&gt;200</td>
</tr>
</tbody></table>
<ul>
<li>tips：<font color="red">其中已提交事务和未提交事务都是根据活跃事务的最小最大事务id进行区分的，实际上在执行到这个查询而生成一致性视图时，仅可分出活跃事务的视图数组。</font></li>
</ul>
</li>
<li><p>查询结果比对规则：</p>
<ul>
<li>在指定时刻下查询，如果查询所在的txn_id落在已提交事务部分，表示这个版本是已提交的事务生成的，可见。</li>
<li>在指定时刻下查询，如果查询所在的txn_id落在未提交事务部分，表示这个版本是由将来启动的事务生成的，不可见；当查询所在的txn_id 就是当前自己的事务，可见。</li>
<li>在指定时刻下查询，如果查询所在的txn_id落在活跃事务(min_id &lt;=txn_id&lt;= max_id)部分，那就包括两种情况。<ul>
<li>若查询所在的txn_id在视图数组中，当查询所在的txn_id就是当前自己的事务是可见的，反之表示这个版本是由还没提交的事务生成的，不可见。</li>
<li>若查询所在的txn_id不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
<li><font color="red">视图数组：[当前活跃事务id]已创建的最大事务id。</font></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RR实现过程解析</p>
<p>废话不多说，先上表格（此表格与上述undolog的事务逻辑无关，不要混淆）。</p>
<p><img src="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E5%92%8CBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/1615119297640.jpg" alt="1615119297640"></p>
</li>
<li><p>上述表格的版本链如下图所示。</p>
<p><img src="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVCC%E5%92%8CBufferPool%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/1615119521671-5119583.jpg" alt="1615119521671"></p>
</li>
</ul>
<ol>
<li>事务4在T3时刻查询结果是24，为什么？<ul>
<li>原因：根据上述一致性视图生成的理论得出事务4的视图数组是**[100,200] 300**，在undolog版本链进行逆向查找。<ul>
<li>首先找到事务id是100的变更记录，发现100落在活跃事务数组区间内、在视图数组中且不是当前自己的事务，不可见。</li>
<li>根据roll_pointer找到事务id是200的，同理，继续查找</li>
<li>找到事务id是300的，且不在视图数组内，可见，<font color="red">返回结果24。</font></li>
</ul>
</li>
</ul>
</li>
<li>事务2在T4时刻提交，为什么事务4在T5时刻查询结果仍然是24？<ul>
<li>原因：事务4的一致性视图在当前事务执行第一次查询时生成，视图数组仍然是**[100,200] 300**，且在整个事务结束之前<font color="red">保持不变。</font></li>
</ul>
</li>
<li>事务2在T4时刻查询结果是22，为什么？<ul>
<li>原因：根据上述一致性视图生成的理论得出事务2的视图数组是**[100,200,300]，在undolog版本链进行逆向查找。</li>
<li>首先找到事务id是100的，发现100落在<font color="red">活跃事务区间内且不是当前自己的事务，不可见</font>。</li>
<li>根据rollback_pointer找到事务id是200的，发现200<font color="red">虽落在活跃事务区间内，但它是当前自己的事务，所以返回结果22。</font></li>
</ul>
</li>
<li>事务5在T7时刻查询结果是18，为什么？<ul>
<li>原因：根据上述一致性视图生成的理论得出事务2的视图数组是**[]300**，在undolog版本链进行逆向查找。</li>
<li>首先找到事务id是100的，发现100属于已提交事务，返回结果18。</li>
</ul>
</li>
</ol>
<h5 id="BUFFER-POOL"><a href="#BUFFER-POOL" class="headerlink" title="BUFFER POOL"></a>BUFFER POOL</h5><p>一条更新语句执行流程：update t set name =’lulu’ where id =2;</p>
<p>server层略过</p>
<ol>
<li>先将id为2的行取出，放到Buffer Pool中</li>
<li>将原始值记录到undo log</li>
<li>更新Buffer Pool</li>
<li>写 redo log Buffer。</li>
<li>准备提交事务。</li>
<li>写redo log  prepared</li>
<li>写bin log</li>
<li>写一个commit的标记到redo log</li>
<li>事务提交</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
