<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>（图）JOIN语句是怎么执行的</title>
    <url>/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一图读懂mysql JOIN语句的执行流程和优化策略。</p>
<a id="more"></a>

<p><img src="/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84.png" alt="JOIN语句是怎么执行的"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）order by语句执行原理及优化策略</title>
    <url>/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>mysql的order by 语句执行原理以及如何优化。</p>
<a id="more"></a>

<p><img src="/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/1.png" alt="order by是怎么工作的？"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我建立了索引，却还是这么慢？</title>
    <url>/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>针对这种疑问，有以下两种情况：</p>
<ol>
<li><strong>优化器没有使用索引。</strong></li>
<li><strong>查询写的不对。</strong></li>
</ol>
<a id="more"></a>

<hr>
<h6 id="优化器没有使用索引"><a href="#优化器没有使用索引" class="headerlink" title="优化器没有使用索引"></a>优化器没有使用索引</h6><ul>
<li>条件字段的函数操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a，cdate字段均存在普通索引。</span><br><span class="line">-- 执行如下sql：</span><br><span class="line">select count(*) from t where month(cdate) &#x3D; &#39;7&#39;;</span><br><span class="line">select * from t where a+1 &#x3D; 1000;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，字段类型为varhcar(32)</span><br><span class="line">select * from t where a &#x3D; 200;</span><br><span class="line">-- 这个sql，存在两个问题：</span><br><span class="line">-- 1.数据类型的转换规则？</span><br><span class="line">-- 答：执行以下select &quot;10&quot; &gt; 9 如果是将字符串转换为数字，则返回结果应该是1，反之为0。</span><br><span class="line">-- 2.为什么走数据类型转换，就走全表扫描？</span><br><span class="line">-- 如果是字符串转换为数字，则上述sql，在执行之前会被优化器处理为：</span><br><span class="line">select * from t where CAST(a AS signed int) &#x3D; 200;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式字符集转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，编码为utf8mb4</span><br><span class="line">-- 表t1中 a1字段存在普通索引 编码为utf8</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; t2.a</span><br><span class="line">-- 由于utf8mb4是utf8的超集，在执行之前会被优化器处理为：</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; CONVERT(t2.a USING utf8mb4)</span><br><span class="line">-- 结果：explain显示，表t2的type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>NULL值比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a is null;</span><br><span class="line">select * from t where a is not null;</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql在对列构建索引时，单列索引无法存储null值，复合索引无法存储全为null的值，这是因为，NULL值无法比较大小，违反了索引树构建时的有序性原则。同理：用null值比较时，不能走索引，只能全表扫描。</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀模糊的查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a like &#39;%reg&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;%reg%&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;reg%&#39;; -- 不一定走全表扫描，mysql会将（全表扫描）的查询消耗和（索引查询+回表）的查询消耗作比较，从而选择出更优的执行计划。</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器在执行此类查询时，不清楚关键字reg是从索引键值的第几个位置开始，所以会根据数据量大小来选择全索引扫描或者全表扫描。</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="查询写的不对。"><a href="#查询写的不对。" class="headerlink" title="查询写的不对。"></a>查询写的不对。</h6><ul>
<li>不合理的分页语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如下业务场景，表t中，存在id,a,b,c,d,e,f字段，有300万行数据，现在要将每一列的值导出至txt文件。</span><br><span class="line">-- A同学考虑到了两个问题：</span><br><span class="line">-- 1.如果没有索引，将会全表扫描，性能较差，也不能建立union_index(a,b,c,d,e,f)代价太高。</span><br><span class="line">-- 综合考虑后，他选择了列值区分度最高的b字段。</span><br><span class="line">-- 2.300万数据一次性加载到服务端，可能会导致服务端发生OOM，于是他想到了分页。</span><br><span class="line">-- 定义初始的pageNum&#x3D;5000，通过计算得到pageSize&#x3D;60;</span><br><span class="line">-- 执行如下sql:（重点关注查询，循环只是简写，并不符合语法要求）</span><br><span class="line">i int default 0;</span><br><span class="line">	while i &lt; 60 do</span><br><span class="line">		select a,b,c,d,e,f from t limit i*5000,5000;</span><br><span class="line">    set i &#x3D; i + 1;</span><br><span class="line">  end while;</span><br><span class="line">-- A同学发现，尽管加了索引，但随着i值的增大，查询还是变的越来越慢。。。</span><br><span class="line">-- explain结果显示，查询走了b字段的索引。那为什么还是会慢呢？</span><br><span class="line">-- 答案是：</span><br><span class="line">-- mysql在执行上述查询时，要先走索引b，一行一行的回表查出a,b,c,d,e,f，然后放弃掉小于i*5000的行。</span><br><span class="line">-- 这会随着i值的增大出现严重的性能问题。</span><br><span class="line">-- 优化办法：延迟关联</span><br><span class="line">select a,b,c,d,e,f from t join (select id from t limit i*5000,5000) t2 on t.id &#x3D; t2.id</span><br><span class="line">-- 由于索引树上的每个值都存在对应主键的值，不需要在回表查询，因此t2的每一行直接在索引树上就可以拿到，查询消耗很小。</span><br><span class="line">-- t2表与t表属于主键关联，优化器在计算驱动表和被驱动表时，会优先将小表做驱动表，大表做被驱动表。</span><br><span class="line">-- 优化器预估t表需要扫描至少3000000行，而t2需要扫描只有5000行。</span><br><span class="line">-- 所以选择：t2表是驱动表，t表是被驱动表</span><br><span class="line">-- 上述查询的逻辑是从t2表中取id字段，去t表中查找主键id匹配的行，直接返回结果。</span><br><span class="line">-- 每次循环共计进行一次索引树扫描，扫描t表5000行。</span><br><span class="line">-- 查询自然很快啦~~~</span><br></pre></td></tr></table></figure>

<ul>
<li>关联子查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where t.a in (select a from t2 where t2.b&#x3D;&#39;c&#39;);</span><br><span class="line">-- mysql5.5之前的版本总是会将上述的in语句优化成如下sql</span><br><span class="line">select * from t where exists (select * from t2 where t2.a &#x3D; t.a and t2.b &#x3D; &#39;c&#39;);</span><br><span class="line">-- 首先解释一下in和exists的执行计划上的区别，抛开优化器将in优化成exists这个不谈(因为mysql5.6以后对in的优化策略有变动)。</span><br><span class="line">-- in语句，mysql优化器会先执行in中的subQuery，将返回的结果集做排序。（符合MRR优化），再去做全表扫描或者索引扫描。</span><br><span class="line">-- exists，mysql先从outerQuery取出一行，去subQuery做等值查询，如此循环直到outQuery循环完最后一行。</span><br><span class="line">-- exists和in的查询效率相同吗？得分情况讨论。</span><br><span class="line">-- t表是大表 t2是小表  in 更快</span><br><span class="line">-- t表时小表 t2是大表  exists 更快</span><br><span class="line">-- 所以在上述任何一个query返回比较慢的时候，决定优化query前，先考虑两张表在业务上，哪张表的数据量较大。</span><br><span class="line">-- 或者选用join来改写上述query，mysql优化器会正确预估驱动表和被驱动表(但需要确定改写成join后不会返回额外的重复记录)。</span><br><span class="line">select t.* from t join t2 on t.a &#x3D; t2.a where t2.b &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>性能提升利器-查询优化</title>
    <url>/2020/12/02/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%88%A9%E5%99%A8-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>内容概览：<ul>
<li>建立合适的索引</li>
<li>优化关联查询</li>
<li>优化子查询</li>
<li>优化ORDER BY</li>
<li>优化LIMIT</li>
<li>UNION 还是 UNION ALL</li>
<li>优化COUNT</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h5><h6 id="什么情况下应该建立索引"><a href="#什么情况下应该建立索引" class="headerlink" title="什么情况下应该建立索引"></a>什么情况下应该建立索引</h6><ol>
<li><p>首先考虑的是建立索引的成本是否可以接受：因为索引本身会占用一定的磁盘空间，如果mysql数据量特别大，建立索引，对查询的执行效率没有太大的提升，但构建索引会耗费更多的磁盘空间，还会在mysql服务器在执行DML操作时需要额外维护一次索引树，影响DML操作的执行效率，对于数据量特别大的表，建议采用分区表。</p>
</li>
<li><p>好，现在建立索引的成本可以接受了，次要考虑的是，索引列的区分度是否较大，对于一些列（比方说：性别，是否删除），这种区分度不大的列，建立索引其实效果很一般。</p>
</li>
<li><p>在where、join、exists中等值匹配的字段。</p>
</li>
<li><p>order by的字段。（这里没办法一句话讲清楚，详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a>）</p>
</li>
</ol>
<h6 id="该建立什么索引"><a href="#该建立什么索引" class="headerlink" title="该建立什么索引"></a>该建立什么索引</h6><p>上述情况都考虑过后，留给我们的问题就是建立什么样的索引：</p>
<ul>
<li><p>普通索引和唯一索引选哪个？：</p>
</li>
<li><p>详情请见<a href="http://www.alualu.cn/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/#more">普通索引和唯一索引的区别</a></p>
</li>
<li><p>该建立多个普通索引，还是一个联合索引？</p>
<ul>
<li><p>联合索引总是遵循<font color="red">最左前缀原则</font>：即对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where b &#x3D; &#39;123&#39;;  -- 无法使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，可以直接在索引上返回结果<font color="red">（mysql5.6引入的索引下推优化）</font>，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t;  -- 可以使用union_idx_abc(a,b,c)</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，当在这些字段上需要排序时，可以利用索引的有序性特点，直接在索引上返回排序结果，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t order by b; </span><br><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39; order by b;</span><br></pre></td></tr></table></figure>

<p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
</li>
</ul>
</li>
</ul>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/#more">一条JOIN语句时怎么执行的</a></p>
<h6 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h6><ul>
<li><p>in 语句优化</p>
<ul>
<li>in语句子查询会导致外层表无法使用索引。详见<a href="https://www.cnblogs.com/wy123/p/7092194.html"><a href="https://www.cnblogs.com/wy123/p/7092194.html">MySQL中IN子查询会导致无法使用索引</a></a></li>
<li>避免in语句的子查询不会返回过多的结果，否则影响查询效率。</li>
<li>尽量将in转化为join，前提是不会产生笛卡尔积。</li>
</ul>
</li>
<li><p>exists语句优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t where exists (select &#39;x&#39; from t2 where t.a &#x3D; t2.a)</span><br></pre></td></tr></table></figure>

<ul>
<li>当出现查询缓慢时，检查t2表的a字段是否存在索引。</li>
<li>t表数据量大时，尽量不要采取此写法，此查询会对t表进行全表或索引扫描，取出t表的每一行的a字段，与t2表的a字段做等值匹配。</li>
</ul>
</li>
</ul>
<h6 id="优化ORDER-BY"><a href="#优化ORDER-BY" class="headerlink" title="优化ORDER BY"></a>优化ORDER BY</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
<h6 id="优化LIMIT"><a href="#优化LIMIT" class="headerlink" title="优化LIMIT"></a>优化LIMIT</h6><ul>
<li>是否能使用上覆盖索引<ul>
<li>通常情况下，limit语句首先要考虑的是能否使用覆盖索引，而不是查询所有的列。</li>
</ul>
</li>
<li>偏移量很大时，建议采取延迟关联<ul>
<li>详情请见<a href="http://www.alualu.cn/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/#more">为什么我建了索引，却还是那么慢？</a>中不合理的分页语句一栏。</li>
</ul>
</li>
</ul>
<h6 id="UNION-还是UNION-ALL"><a href="#UNION-还是UNION-ALL" class="headerlink" title="UNION 还是UNION ALL?"></a>UNION 还是UNION ALL?</h6><ul>
<li><p>如何优化</p>
<ul>
<li>mysql总是将UNION [ALL]的结果集放入一张临时表中，导致很多优化策略都没办法使用，通常情况下我们需要将where、limit、order by等语句下推到UNON [ALL]的子查询中，以便优化器能充分的利用这些条件来优化查询。</li>
</ul>
</li>
<li><p>UNION和UNION ALL的区别</p>
<ul>
<li>UNION：mysql将UNION左右的查询全部放入一张临时表中，然后使用DISTINCT对临时表做唯一性检查，确保唯一性的情况下将数据行返回给客户端。</li>
<li>UNION ALL ：mysql将UNION左右的查询全部放入一张临时表中，然后返回给客户端。</li>
</ul>
</li>
<li><p>UNION和UNION ALL，我该选哪个？</p>
<ul>
<li>除非客户端需要返回去重的数据，否则一定要使用UNION ALL</li>
</ul>
</li>
</ul>
<h6 id="优化COUNT"><a href="#优化COUNT" class="headerlink" title="优化COUNT"></a>优化COUNT</h6><ul>
<li>COUNT(id)，COUNT(1)，COUNT(字段)，COUNT(*)，我该选哪个？<ul>
<li>COUNT(id)：mysql会遍历整张表，将主键id的值取出来，返回给server层，server判断不可能为空，逐行累加。</li>
<li>COUNT(1)：innodb扫描每一行，但不取值， server对返回的每一行数据，记录一个数字“1”进去，判断数字“1”不可能为空，逐行累加。</li>
<li>COUNT(字段)：如果字段定义not null，mysql遍历整张表，将该字段取出来，判断该字段不可能为null，逐行累加；如果字段定义允许为null，mysql还要额外将<font color="red">字段的值</font>取出来，判断如果不是NULL才累加。</li>
<li>COUNT(<em>)：mysql对COUNT(\</em>)做了专门的优化，*并不是取出表的所有字段，不需要取值，COUNT(*)肯定不是NULL，直接逐行累加。</li>
</ul>
</li>
<li>上述4种COUNT哪个快？<ul>
<li>按执行效率而言，COUNT(*)≈COUNT(1)&gt;COUNT(id)&gt;COUNT(字段)。</li>
<li>如果没有特殊的业务需求，建议采用COUNT(*)。</li>
</ul>
</li>
<li>我采用了COUNT(*)，但表太大还是很慢怎么办？<ul>
<li>建议单独建立计数器表，记录表名和表记录数，执行关于被记录表的DML语句时，在同一个事务内，对该计数器表进行更新（+1 or  -1）。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法-数组</title>
    <url>/2020/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<a id="more"></a>

<h6 id="数组的数据结构"><a href="#数组的数据结构" class="headerlink" title="数组的数据结构"></a>数组的数据结构</h6><ul>
<li><p>数组是是一种线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。</p>
</li>
<li><p>数组的特点</p>
<ul>
<li>连续性：在内存中是必须是连续的，如果需要在内存中申请size=100M的数组，如果内存中的连续的内存空间不足100M，会申请失败。</li>
<li>相同类型：数组中仅支持存储基本类型的数据，且一个数组只能存储一个类型的数据。</li>
<li>查找效率：数据支持下标查找，其时间复杂度是O(1)。</li>
</ul>
</li>
<li><p>为什么数组只能支持存储一种类型的数据。</p>
<ul>
<li><p>原因是，数组在内存中是连续的，需要按固定的数据类型字节数来查找其在内存中的数据。如下图，假定起始地址base_address=1000，则数组中元素的在内存中查找公式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i].address = base_address+i*data_type_size</span><br><span class="line"><span class="comment">//其中data_type_size为存储的数据类型所占的字节数，图例中为int，占4个字节。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84-7861521.png" alt="数组"></p>
<ul>
<li><p>低效的插入和删除</p>
<ul>
<li>插入操作<ul>
<li>假定数组长度为n，现在要插入一个数据到数组的第k个元素，则需要将k~n个元素依次顺序向后移动一位。<ul>
<li>最坏时间复杂度：k是数组的第一个元素，在需要将数组的数据全部向后移动一位，时间复杂度为O(n)</li>
<li>最好时间复杂度：k是数组的最后一个元素，则不需要任何数据搬移操作，直接插入，时间复杂度为O(1)。</li>
<li>平均时间复杂度：(1+2+3+…+n)/n=O(n)。</li>
</ul>
</li>
</ul>
</li>
<li>删除操作<ul>
<li>跟插入操作的时间复杂度一样，不过删除操作可以优化。</li>
<li>优化思路：CPU的标记清除垃圾回收算法。<ul>
<li>需要删除a中的数据时，只是将a中需要删除的数据单独记录在一个独立的空间里，当数组没有更多的空间存储数据时，再将其中的内容一次性的删除，这样就减少了很多次的数据搬移操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList是否能完全代替Array？</p>
<ul>
<li><p>在java中，ArrayList最大的优势就是将插入，删除等操作封装起来，另外，它还支持<font color="red">动态扩容</font>。</p>
<ul>
<li><p>动态扩容：假定初始我们定义了一个长度为10的ArrayList，当插入第11个元素时，ArrayList会自动申请一个1.5倍大小的新的ArrayList，再将当前数据copy过去，这在ArrayList数据量大时，是非常浪费时间和空间的，在预先知道要存储多少数据时，建议初始化申请就申请定长的ArrayList，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-链表</title>
    <url>/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><h6 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h6><ul>
<li><p>链表是将一组零散的内存空间通过链式数据结构存储起来，与数组不同的是，链表不需要连续的内存空间，他是通过一组指针将零散的内存块连续起来使用，假定内存中连续的内存空间不足100mb，我们申请100mb大小的链表是完全不会有问题的。</p>
<a id="more"></a>

</li>
</ul>
<h6 id="常用的链表"><a href="#常用的链表" class="headerlink" title="常用的链表"></a>常用的链表</h6><ul>
<li>常用的链表有：单链表、双向链表、循环链表<ul>
<li>单链表：单链表的节点除了存储当前节点的data外，还需要存储下一节点的地址，故单链表中，所有的节点只知道自己下一个节点是谁，尾结点的下一节点为null，。</li>
<li>双向链表：与单链表不同的是，双向链表除了存储下一节点的地址外，还存储了其上一节点的地址，尾节点的下一节点也是null。</li>
<li>循环链表：循环链表较上述两个链表的区别是，循环链表将尾结点的下一节点指针，指向了头结点。</li>
</ul>
</li>
</ul>
<h5 id="java实现单链表"><a href="#java实现单链表" class="headerlink" title="java实现单链表"></a>java实现单链表</h5><h6 id="节点实现类"><a href="#节点实现类" class="headerlink" title="节点实现类"></a>节点实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一节点的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; nextNode;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node&lt;T&gt; nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写equals，便于接下来的对象比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj || <span class="keyword">this</span>.getData().equals(((Node)obj).getData())) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="单链表实现类"><a href="#单链表实现类" class="headerlink" title="单链表实现类"></a>单链表实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的实现类：</span></span><br><span class="line"><span class="comment"> * 单链表特性：</span></span><br><span class="line"><span class="comment"> * 每个节点只知道自己下一个节点是谁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; headNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从尾节点开始插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node p = headNode;</span><br><span class="line">            <span class="keyword">while</span> (p.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p = p.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">            p.setNextNode(nextNode);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从头结点插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToFirstNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明已有节点在head,需要让新节点的下一节点指向当前你head节点，再将新节点赋值给head节点。</span></span><br><span class="line">            nextNode.setNextNode(headNode);</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据下标获取链表中的节点元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index &gt; getSize()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; node = headNode.getNextNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == index - <span class="number">1</span>)&#123;</span><br><span class="line">                node = node.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;&#123;\&quot;curr\&quot;:\&quot;&quot;</span>+p.getData()+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;next\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> ? p.getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.substring(<span class="number">0</span>,stringBuffer.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据节点删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByNode</span><span class="params">(Node&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; headNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果待删除的节点是头结点，直接将头结点的下一节点赋值给头结点，就实现了节点删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(p == headNode)&#123;</span><br><span class="line">            headNode = headNode.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果不是头节点，则从当前链表的头结点开始顺序查找下一节点，直到等于待删除的节点为止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;T&gt; q = headNode;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span> &amp;&amp; ! q.getNextNode().equals(p))&#123;</span><br><span class="line">            q = q.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果q为null，说明没有匹配的待删除的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(q == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  匹配到，将当前q节点的下一节点指向下下一个节点，就实现了节点删除。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        q.setNextNode(q.getNextNode().getNextNode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据节点数据删除（删除多节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByData</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(headNode.getData().equals(data))&#123;</span><br><span class="line">            headNode = headNode.getNextNode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果不是头节点，则从当前链表的头结点开始顺序查找下一节点，直到等于待删除的节点为止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt; q = headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.getNextNode().getData().equals(data))&#123;</span><br><span class="line">                q.setNextNode(q.getNextNode().getNextNode());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingLeLinkListTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleLinkList&lt;String&gt; singleLinkList = <span class="keyword">new</span> SingleLinkList&lt;String&gt;();</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.add(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"><span class="comment">//        singleLinkList.addToFirstNode(&quot;000&quot;);</span></span><br><span class="line"><span class="comment">//        Node&lt;String&gt; delNode = new Node&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//        delNode.setData(&quot;333&quot;);</span></span><br><span class="line"><span class="comment">//        singleLinkList.deleteByNode(delNode);</span></span><br><span class="line">        singleLinkList.deleteByData(<span class="string">&quot;555&quot;</span>);</span><br><span class="line">        singleLinkList.printAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="基于单链表实现LRU算法"><a href="#基于单链表实现LRU算法" class="headerlink" title="基于单链表实现LRU算法"></a>基于单链表实现LRU算法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> day01.singleLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于链表实现LRU缓存失效算法</span></span><br><span class="line"><span class="comment"> * 即固定的链表大小中，最多次访问的排在最前面，超出链表大小后淘汰最后面的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> alualu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; headNode;</span><br><span class="line">    <span class="comment">//缓存总容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//当前缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = DEFAULT_CAPACITY;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedList</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        headNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据data找链表中匹配节点的前一个节点，</span></span><br><span class="line"><span class="comment">     * 后续要通过此节点来执行节点删除操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">findPreNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;T&gt; p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p.getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.equals(p.getNextNode().getData()))&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟缓存入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断缓存中是否已经存在此数据</span></span><br><span class="line">        Node&lt;T&gt; p = findPreNode(data);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将此数据从链表中删除</span></span><br><span class="line">            deleteByPreNode(p);</span><br><span class="line">            <span class="comment">//重新插入链表头部</span></span><br><span class="line">            addToFirstNode(data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//判断加入数据后是否超出capacity</span></span><br><span class="line">            <span class="keyword">int</span> postSize = size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(postSize &gt; capacity)&#123;</span><br><span class="line">              <span class="comment">//需要删除最后一个节点，再加入新的节点</span></span><br><span class="line">                deleteLastNode();</span><br><span class="line">                addToFirstNode(data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//直接加入新的节点</span></span><br><span class="line">                addToFirstNode(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByPreNode</span><span class="params">(Node&lt;T&gt; preNode)</span></span>&#123;</span><br><span class="line">        preNode.setNextNode(preNode.getNextNode().getNextNode());</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteLastNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p.getNextNode().getNextNode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p.setNextNode(<span class="keyword">null</span>);</span><br><span class="line">        size -- ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从头结点插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToFirstNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; nextNode = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        nextNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span>(headNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明已有节点在head,需要让新节点的下一节点指向当前你head节点，再将新节点赋值给head节点。</span></span><br><span class="line">            nextNode.setNextNode(headNode);</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node p = headNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;&#123;\&quot;curr\&quot;:\&quot;&quot;</span>+p.getData()+<span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">            p = p.getNextNode();</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;\&quot;next\&quot;:\&quot;&quot;</span>+(p != <span class="keyword">null</span> ? p.getData() : <span class="keyword">null</span>)+<span class="string">&quot;\&quot;&#125;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuffer.substring(<span class="number">0</span>,stringBuffer.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化缓存列表</span></span><br><span class="line">        LRULinkedList&lt;String&gt; lruLinkedList = <span class="keyword">new</span> LRULinkedList&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//模拟入栈操作</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;000&quot;</span>);</span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        <span class="comment">//模拟缓存入栈时，缓存清除策略</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        <span class="comment">//模拟缓存入栈时命中已有缓存。</span></span><br><span class="line">        lruLinkedList.offer(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        lruLinkedList.printAll();</span><br><span class="line">        System.out.println(lruLinkedList.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）普通索引和唯一索引的区别</title>
    <url>/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>整理一下mysql普通索引和唯一索引的区别。</p>
<a id="more"></a>

<p><img src="/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB-7577954.png" alt="普通索引和唯一索引的区别"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>重要的日志模块，redolog和binlog</title>
    <url>/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/</url>
    <content><![CDATA[<ul>
<li>内容概览：<ul>
<li>更新语句的执行流程</li>
<li>什么是redolog，什么是binlog</li>
<li>什么是两阶段提交</li>
<li>为什么需要两阶段提交</li>
<li>redolog和change buffer的区别</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/911607253188_.pic.jpg" alt="9116072" style="zoom:0%;">

<ul>
<li>连接器<ul>
<li>客户端发出连接请求时，mysql连接器做身份认证，权限查询，并且会将本次权限查询的结果记录起来，应用于此次连接的整个过程，直到连接被终止，<font color="red">所以，mysql修改用户权限时需要重新登录。</font></li>
</ul>
</li>
<li>查询缓存<ul>
<li>mysql会将历史查询的结果以key-value的形式缓存在内存中，key便是查询语句，判断查询缓存是否成功匹配的方式是将本次执行的sql与key进行强关联，sql语句中任何字符，例如空格，换行不匹配都会导致缓存未命中，<font color="red">执行表的更新语句时，会将该表的查询缓存全部清空。</font></li>
<li>一般情况下，查询缓存的命中率非常低，很可能费劲的将查询缓存起来，却被一条更新语句全部清空了，并且缓存清空的过程会持有全局锁，任何跟此缓存有关的查询都需要等待这个锁的释放。</li>
</ul>
</li>
<li>分析器<ul>
<li>进行词法分析，语法分析，将sql语句解析成语法树。</li>
</ul>
</li>
<li>优化器<ul>
<li>优化查询语句，包括调整JOIN语句的关联顺序、索引选择、覆盖索引扫描、提前终止查询等操作，生成执行计划交给执行器。</li>
</ul>
</li>
<li>执行器<ul>
<li>执行优化器提供的语句，如果上述的更新语句，mysql会将此更新做了什么改动记录在redo log里面，并生成此记录的binlog，一起写入磁盘。</li>
</ul>
</li>
</ul>
<h5 id="什么是redolog"><a href="#什么是redolog" class="headerlink" title="什么是redolog?"></a>什么是redolog?</h5><ul>
<li><p>摘自极客时间《MYSQL实战45讲：一条更新语句时如何执行的？》</p>
</li>
<li><p>“粉板”的案例</p>
<p>​        酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。<br>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li><p>直接把账本翻出来，把这次赊的账加上去或者扣除掉；</p>
</li>
<li><p>先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p>
</li>
</ul>
<p>​      在生意很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。<br>​      同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
</li>
<li><p>这个粉板其实就是redo log，<font color="red">数据写入redo log中，状态便更新为prepare，表示随时可以commit</font>。</p>
</li>
<li><p>粉板和账本配合的过程其实就是mysql的WAL（write ahead logging）机制，他的关键点是先写日志，等不忙的时候再更新到磁盘。</p>
</li>
<li><p>假如粉板写满了，也就是下图中wirte pos和checkpoint重合时，mysql就不得不停下DML操作，将redolog上的操作写入磁盘再记录到binlog，同时将checkout point向前推进。</p>
</li>
</ul>
<p><img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/921607253189_.pic.jpg" alt="921607253189_.pic"></p>
<h5 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a>什么是binlog</h5><ul>
<li><p>binlog是mysql server层特有的日志系统，称为mysql的归档日志，采用“追加写”的方式来记录操作日志。</p>
</li>
<li><p>binlog有固定的大小，超过这个大小会新启一个binglog文件来记录。</p>
</li>
<li><p>binlog记录的是逻辑操作，记录的是将username=’lulu’的age修改为16，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><ul>
<li><p>什么是两阶段提交？</p>
<p>mysql将redolog的写入拆分成两个步骤，用不同的状态来标识，一个是prepare状态，另一个是commit状态，这就是两阶段提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行器从username的索引树上查找符合username=’lulu’的记录，回表取出age。</p>
</li>
<li><p>执行器拿到引擎给数据，将值更新为16，再调用接口写入数据。</p>
</li>
<li><p>引擎将这行数据更新到内存中，并将这次的更新操作记录到redolog里面，此时redolog处于prepare状态。</p>
</li>
<li><p>生成此次更新的binlog，并将binlog写入磁盘。</p>
</li>
<li><p>执行器调用事务提交的接口，将刚刚写入的redolog的prepare状态修改为commit状态。</p>
</li>
</ul>
<h5 id="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"><a href="#为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？" class="headerlink" title="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"></a>为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？</h5><ul>
<li><p>首先要解释的一点是：innodb采用redolog，是支持崩溃恢复的。</p>
</li>
<li><p>先写redolog，后写binlog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写redolog，commit。</span><br><span class="line">-- step3: 写binlog。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，此事务的redolog已经记录完成，数据依旧可以从redolog恢复（age=24）。</li>
<li>但由于redolog的状态是commit，mysql不会再触发写入binlog的过程。由于binlog缺失这部分的变更归档，后续使用binlog做数据恢复时lulu依旧是18岁。</li>
</ul>
</li>
</ul>
</li>
<li><p>先写binlog，再写redolog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写binlog。</span><br><span class="line">-- step3: 写redolog，commit。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，由于redolog没有记录变更日志，所以此次事务无效。</li>
<li>但binlog多了这部分的归档，后续使用binlog做数据恢复是lulu变成了24岁。</li>
</ul>
</li>
</ul>
</li>
<li><p>结论：如果不采用两阶段提交，innodb就无法保证，crash之后数据一致性。</p>
</li>
</ul>
<h5 id="redolog和change-buffer的区别"><a href="#redolog和change-buffer的区别" class="headerlink" title="redolog和change buffer的区别"></a>redolog和change buffer的区别</h5><ul>
<li><p>区别一：记录的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- 如果数据在内存中：</span><br><span class="line">-- 此次更新与change buffer无关，</span><br><span class="line">-- redolog会记录以下内容：update(&#39;lulu&#39;,&#39;18&#39;) -&gt; (&#39;lulu&#39;,&#39;24&#39;) to page1</span><br><span class="line">-- 如果数据不在内存中：</span><br><span class="line">-- mysql在内存的buffer pool中生成关于本次操作的change buffer 并记录：我要将username&#x3D;&#39;lulu&#39;的age修改为24.</span><br><span class="line">-- redolog会记录以下内容：new change buffer item[update(&#39;lulu&#39;,&#39;18&#39;) -&gt; (&#39;lulu&#39;,&#39;24&#39;) to page1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别二：崩溃恢复</p>
<ul>
<li>redolog：是实现innodb的crash safe不可或缺的一部分，innodb的崩溃数据恢复主要依赖于redolog。</li>
<li>change buffer：异常崩溃后，change buffer的内容丢失，如果redolog记录了此次change buffer的内容，则可以恢复。如果redolog没记录，说明此次事务没提交就崩溃了。</li>
</ul>
</li>
<li><p>区别三：更新性能上的收益</p>
<ul>
<li>redolog：节省随机写磁盘的IO消耗，转成顺序写。</li>
<li>change buffer：节省随机读盘的IO消耗。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
