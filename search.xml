<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>（图）JOIN语句是怎么执行的</title>
    <url>/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一图读懂mysql JOIN语句的执行流程和优化策略。</p>
<a id="more"></a>

<p><img src="/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84.png" alt="JOIN语句是怎么执行的"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）order by语句执行原理及优化策略</title>
    <url>/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>mysql的order by 语句执行原理以及如何优化。</p>
<a id="more"></a>

<p><img src="/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/1.png" alt="order by是怎么工作的？"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我建立了索引，却还是这么慢？</title>
    <url>/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>针对这种疑问，有以下两种情况：</p>
<ol>
<li><strong>优化器没有使用索引。</strong></li>
<li><strong>查询写的不对。</strong></li>
</ol>
<a id="more"></a>

<hr>
<h6 id="优化器没有使用索引"><a href="#优化器没有使用索引" class="headerlink" title="优化器没有使用索引"></a>优化器没有使用索引</h6><ul>
<li>条件字段的函数操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a，cdate字段均存在普通索引。</span><br><span class="line">-- 执行如下sql：</span><br><span class="line">select count(*) from t where month(cdate) &#x3D; &#39;7&#39;;</span><br><span class="line">select * from t where a+1 &#x3D; 1000;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，字段类型为varhcar(32)</span><br><span class="line">select * from t where a &#x3D; 200;</span><br><span class="line">-- 这个sql，存在两个问题：</span><br><span class="line">-- 1.数据类型的转换规则？</span><br><span class="line">-- 答：执行以下select &quot;10&quot; &gt; 9 如果是将字符串转换为数字，则返回结果应该是1，反之为0。</span><br><span class="line">-- 2.为什么走数据类型转换，就走全表扫描？</span><br><span class="line">-- 如果是字符串转换为数字，则上述sql，在执行之前会被优化器处理为：</span><br><span class="line">select * from t where CAST(a AS signed int) &#x3D; 200;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式字符集转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，编码为utf8mb4</span><br><span class="line">-- 表t1中 a1字段存在普通索引 编码为utf8</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; t2.a</span><br><span class="line">-- 由于utf8mb4是utf8的超集，在执行之前会被优化器处理为：</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; CONVERT(t2.a USING utf8mb4)</span><br><span class="line">-- 结果：explain显示，表t2的type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>NULL值比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a is null;</span><br><span class="line">select * from t where a is not null;</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql在对列构建索引时，单列索引无法存储null值，复合索引无法存储全为null的值，这是因为，NULL值无法比较大小，违反了索引树构建时的有序性原则。同理：用null值比较时，不能走索引，只能全表扫描。</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀模糊的查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a like &#39;%reg&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;%reg%&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;reg%&#39;; -- 不一定走全表扫描，mysql会将（全表扫描）的查询消耗和（索引查询+回表）的查询消耗作比较，从而选择出更优的执行计划。</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器在执行此类查询时，不清楚关键字reg是从索引键值的第几个位置开始，所以会根据数据量大小来选择全索引扫描或者全表扫描。</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="查询写的不对。"><a href="#查询写的不对。" class="headerlink" title="查询写的不对。"></a>查询写的不对。</h6><ul>
<li>不合理的分页语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如下业务场景，表t中，存在id,a,b,c,d,e,f字段，有300万行数据，现在要将每一列的值导出至txt文件。</span><br><span class="line">-- A同学考虑到了两个问题：</span><br><span class="line">-- 1.如果没有索引，将会全表扫描，性能较差，也不能建立union_index(a,b,c,d,e,f)代价太高。</span><br><span class="line">-- 综合考虑后，他选择了列值区分度最高的b字段。</span><br><span class="line">-- 2.300万数据一次性加载到服务端，可能会导致服务端发生OOM，于是他想到了分页。</span><br><span class="line">-- 定义初始的pageNum&#x3D;5000，通过计算得到pageSize&#x3D;60;</span><br><span class="line">-- 执行如下sql:（重点关注查询，循环只是简写，并不符合语法要求）</span><br><span class="line">i int default 0;</span><br><span class="line">	while i &lt; 60 do</span><br><span class="line">		select a,b,c,d,e,f from t limit i*5000,5000;</span><br><span class="line">    set i &#x3D; i + 1;</span><br><span class="line">  end while;</span><br><span class="line">-- A同学发现，尽管加了索引，但随着i值的增大，查询还是变的越来越慢。。。</span><br><span class="line">-- explain结果显示，查询走了b字段的索引。那为什么还是会慢呢？</span><br><span class="line">-- 答案是：</span><br><span class="line">-- mysql在执行上述查询时，要先走索引b，一行一行的回表查出a,b,c,d,e,f，然后放弃掉小于i*5000的行。</span><br><span class="line">-- 这会随着i值的增大出现严重的性能问题。</span><br><span class="line">-- 优化办法：延迟关联</span><br><span class="line">select a,b,c,d,e,f from t join (select id from t limit i*5000,5000) t2 on t.id &#x3D; t2.id</span><br><span class="line">-- 由于索引树上的每个值都存在对应主键的值，不需要在回表查询，因此t2的每一行直接在索引树上就可以拿到，查询消耗很小。</span><br><span class="line">-- t2表与t表属于主键关联，优化器在计算驱动表和被驱动表时，会优先将小表做驱动表，大表做被驱动表。</span><br><span class="line">-- 优化器预估t表需要扫描至少3000000行，而t2需要扫描只有5000行。</span><br><span class="line">-- 所以选择：t2表是驱动表，t表是被驱动表</span><br><span class="line">-- 上述查询的逻辑是从t2表中取id字段，去t表中查找主键id匹配的行，直接返回结果。</span><br><span class="line">-- 每次循环共计进行一次索引树扫描，扫描t表5000行。</span><br><span class="line">-- 查询自然很快啦~~~</span><br></pre></td></tr></table></figure>

<ul>
<li>关联子查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where t.a in (select a from t2 where t2.b&#x3D;&#39;c&#39;);</span><br><span class="line">-- mysql5.5之前的版本总是会将上述的in语句优化成如下sql</span><br><span class="line">select * from t where exists (select * from t2 where t2.a &#x3D; t.a and t2.b &#x3D; &#39;c&#39;);</span><br><span class="line">-- 首先解释一下in和exists的执行计划上的区别，抛开优化器将in优化成exists这个不谈(因为mysql5.6以后对in的优化策略有变动)。</span><br><span class="line">-- in语句，mysql优化器会先执行in中的subQuery，将返回的结果集做排序。（符合MRR优化），再去做全表扫描或者索引扫描。</span><br><span class="line">-- exists，mysql先从outerQuery取出一行，去subQuery做等值查询，如此循环直到outQuery循环完最后一行。</span><br><span class="line">-- exists和in的查询效率相同吗？得分情况讨论。</span><br><span class="line">-- t表是大表 t2是小表  in 更快</span><br><span class="line">-- t表时小表 t2是大表  exists 更快</span><br><span class="line">-- 所以在上述任何一个query返回比较慢的时候，决定优化query前，先考虑两张表在业务上，哪张表的数据量较大。</span><br><span class="line">-- 或者选用join来改写上述query，mysql优化器会正确预估驱动表和被驱动表(但需要确定改写成join后不会返回额外的重复记录)。</span><br><span class="line">select t.* from t join t2 on t.a &#x3D; t2.a where t2.b &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>性能提升利器-查询优化</title>
    <url>/2020/12/02/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%88%A9%E5%99%A8-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>本文有以下内容：<ul>
<li>建立合适的索引</li>
<li>优化关联查询</li>
<li>优化子查询</li>
<li>优化ORDER BY</li>
<li>优化LIMIT</li>
<li>UNION 还是 UNION ALL</li>
<li>优化COUNT</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h5><h6 id="什么情况下应该建立索引"><a href="#什么情况下应该建立索引" class="headerlink" title="什么情况下应该建立索引"></a>什么情况下应该建立索引</h6><ol>
<li><p>首先考虑的是建立索引的成本是否可以接受：因为索引本身会占用一定的磁盘空间，如果mysql数据量特别大，建立索引，对查询的执行效率没有太大的提升，但构建索引会耗费更多的磁盘空间，还会在mysql服务器在执行DML操作时需要额外维护一次索引树，影响DML操作的执行效率，对于数据量特别大的表，建议采用分区表。</p>
</li>
<li><p>好，现在建立索引的成本可以接受了，次要考虑的是，索引列的区分度是否较大，对于一些列（比方说：性别，是否删除），这种区分度不大的列，建立索引其实效果很一般。</p>
</li>
<li><p>在where、join、exists中等值匹配的字段。</p>
</li>
<li><p>order by的字段。（这里没办法一句话讲清楚，详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a>）</p>
</li>
</ol>
<h6 id="该建立什么索引"><a href="#该建立什么索引" class="headerlink" title="该建立什么索引"></a>该建立什么索引</h6><p>上述情况都考虑过后，留给我们的问题就是建立什么样的索引：</p>
<ul>
<li><p>普通索引和唯一索引选哪个？：</p>
</li>
<li><p>详情请见<a href="http://www.alualu.cn/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/#more">普通索引和唯一索引的区别</a></p>
</li>
<li><p>该建立多个普通索引，还是一个联合索引？</p>
<ul>
<li><p>联合索引总是遵循<font color="red">最左前缀原则</font>：即对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where b &#x3D; &#39;123&#39;;  -- 无法使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，可以直接在索引上返回结果<font color="red">（mysql5.6引入的索引下推优化）</font>，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t;  -- 可以使用union_idx_abc(a,b,c)</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，当在这些字段上需要排序时，可以利用索引的有序性特点，直接在索引上返回排序结果，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t order by b; </span><br><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39; order by b;</span><br></pre></td></tr></table></figure>

<p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
</li>
</ul>
</li>
</ul>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/#more">一条JOIN语句时怎么执行的</a></p>
<h6 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h6><ul>
<li><p>in 语句优化</p>
<ul>
<li>in语句子查询会导致外层表无法使用索引。详见<a href="https://www.cnblogs.com/wy123/p/7092194.html"><a href="https://www.cnblogs.com/wy123/p/7092194.html">MySQL中IN子查询会导致无法使用索引</a></a></li>
<li>避免in语句的子查询不会返回过多的结果，否则影响查询效率。</li>
<li>尽量将in转化为join，前提是不会产生笛卡尔积。</li>
</ul>
</li>
<li><p>exists语句优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t where exists (select &#39;x&#39; from t2 where t.a &#x3D; t2.a)</span><br></pre></td></tr></table></figure>

<ul>
<li>当出现查询缓慢时，检查t2表的a字段是否存在索引。</li>
<li>t表数据量大时，尽量不要采取此写法，此查询会对t表进行全表或索引扫描，取出t表的每一行的a字段，与t2表的a字段做等值匹配。</li>
</ul>
</li>
</ul>
<h6 id="优化ORDER-BY"><a href="#优化ORDER-BY" class="headerlink" title="优化ORDER BY"></a>优化ORDER BY</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
<h6 id="优化LIMIT"><a href="#优化LIMIT" class="headerlink" title="优化LIMIT"></a>优化LIMIT</h6><ul>
<li>是否能使用上覆盖索引<ul>
<li>通常情况下，limit语句首先要考虑的是能否使用覆盖索引，而不是查询所有的列。</li>
</ul>
</li>
<li>偏移量很大时，建议采取延迟关联<ul>
<li>详情请见<a href="http://www.alualu.cn/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/#more">为什么我建了索引，却还是那么慢？</a>中不合理的分页语句一栏。</li>
</ul>
</li>
</ul>
<h6 id="UNION-还是UNION-ALL"><a href="#UNION-还是UNION-ALL" class="headerlink" title="UNION 还是UNION ALL?"></a>UNION 还是UNION ALL?</h6><ul>
<li><p>如何优化</p>
<ul>
<li>mysql总是将UNION [ALL]的结果集放入一张临时表中，导致很多优化策略都没办法使用，通常情况下我们需要将where、limit、order by等语句下推到UNON [ALL]的子查询中，以便优化器能充分的利用这些条件来优化查询。</li>
</ul>
</li>
<li><p>UNION和UNION ALL的区别</p>
<ul>
<li>UNION：mysql将UNION左右的查询全部放入一张临时表中，然后使用DISTINCT对临时表做唯一性检查，确保唯一性的情况下将数据行返回给客户端。</li>
<li>UNION ALL ：mysql将UNION左右的查询全部放入一张临时表中，然后返回给客户端。</li>
</ul>
</li>
<li><p>UNION和UNION ALL，我该选哪个？</p>
<ul>
<li>除非客户端需要返回去重的数据，否则一定要使用UNION ALL</li>
</ul>
</li>
</ul>
<h6 id="优化COUNT"><a href="#优化COUNT" class="headerlink" title="优化COUNT"></a>优化COUNT</h6><ul>
<li>COUNT(id)，COUNT(1)，COUNT(字段)，COUNT(*)，我该选哪个？<ul>
<li>COUNT(id)：mysql会遍历整张表，将主键id的值取出来，返回给server层，server判断不可能为空，逐行累加。</li>
<li>COUNT(1)：innodb扫描每一行，但不取值， server对返回的每一行数据，记录一个数字“1”进去，判断数字“1”不可能为空，逐行累加。</li>
<li>COUNT(字段)：如果字段定义not null，mysql遍历整张表，将该字段取出来，判断该字段不可能为null，逐行累加；如果字段定义允许为null，mysql还要额外将<font color="red">字段的值</font>取出来，判断如果不是NULL才累加。</li>
<li>COUNT(<em>)：mysql对COUNT(\</em>)做了专门的优化，*并不是取出表的所有字段，不需要取值，COUNT(*)肯定不是NULL，直接逐行累加。</li>
</ul>
</li>
<li>上述4种COUNT哪个快？<ul>
<li>按执行效率而言，COUNT(*)≈COUNT(1)&gt;COUNT(id)&gt;COUNT(字段)。</li>
<li>如果没有特殊的业务需求，建议采用COUNT(*)。</li>
</ul>
</li>
<li>我采用了COUNT(*)，但表太大还是很慢怎么办？<ul>
<li>建议单独建立计数器表，记录表名和表记录数，执行关于被记录表的DML语句时，在同一个事务内，对该计数器表进行更新（+1 or  -1）。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）普通索引和唯一索引的区别</title>
    <url>/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>整理一下mysql普通索引和唯一索引的区别。</p>
<a id="more"></a>

<p><img src="/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB-6659675.png" alt="普通索引和唯一索引的区别"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>重要的日志模块，redolog和binlog</title>
    <url>/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/</url>
    <content><![CDATA[<ul>
<li>本文有以下内容：<ul>
<li>更新语句的执行流程</li>
<li>什么是redolog，什么是binlog</li>
<li>什么是两阶段提交</li>
<li>为什么需要两阶段提交</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h5 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/911607253188_.pic.jpg" alt="9116072" style="zoom:0%;">

<ul>
<li>连接器<ul>
<li>客户端发出连接请求时，mysql连接器做身份认证，权限查询，并且会将本次权限查询的结果记录起来，应用于此次连接的整个过程，直到连接被终止，<font color="red">所以，mysql修改用户权限时需要重新登录。</font></li>
</ul>
</li>
<li>查询缓存<ul>
<li>mysql会将历史查询的结果以key-value的形式缓存在内存中，key便是查询语句，判断查询缓存是否成功匹配的方式是将本次执行的sql与key进行强关联，sql语句中任何字符，例如空格，换行不匹配都会导致缓存未命中，<font color="red">执行表的更新语句时，会将该表的查询缓存全部清空。</font></li>
<li>一般情况下，查询缓存的命中率非常低，很可能费劲的将查询缓存起来，却被一条更新语句全部清空了，并且缓存清空的过程会持有全局锁，任何跟此缓存有关的查询都需要等待这个锁的释放。</li>
</ul>
</li>
<li>分析器<ul>
<li>进行词法分析，语法分析，将sql语句解析成语法树。</li>
</ul>
</li>
<li>优化器<ul>
<li>优化查询语句，包括调整JOIN语句的关联顺序、索引选择、覆盖索引扫描、提前终止查询等操作，生成执行计划交给执行器。</li>
</ul>
</li>
<li>执行器<ul>
<li>执行优化器提供的语句，如果上述的更新语句，mysql会将此更新做了什么改动记录在redo log里面，并生成此记录的binlog，一起写入磁盘。</li>
</ul>
</li>
</ul>
<h5 id="什么是redolog"><a href="#什么是redolog" class="headerlink" title="什么是redolog?"></a>什么是redolog?</h5><ul>
<li><p>摘自极客时间《MYSQL实战45讲：一条更新语句时如何执行的？》</p>
</li>
<li><p>“粉板”的案例</p>
<p>​        酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。<br>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li><p>直接把账本翻出来，把这次赊的账加上去或者扣除掉；</p>
</li>
<li><p>先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p>
</li>
</ul>
<p>​      在生意很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。<br>​      同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
</li>
<li><p>这个粉板其实就是redo log，<font color="red">数据写入redo log中，状态便更新为prepare，表示随时可以commit</font>。</p>
</li>
<li><p>粉板和账本配合的过程其实就是mysql的WAL（write ahead logging）机制，他的关键点是先写日志，等不忙的时候再更新到磁盘。</p>
</li>
<li><p>假如粉板写满了，也就是下图中wirte pos和checkpoint重合时，mysql就不得不停下DML操作，将redolog上的操作写入磁盘再记录到binlog，同时将checkout point向前推进。</p>
</li>
</ul>
<p><img src="/2020/12/06/%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%EF%BC%8Credolog%E5%92%8Cbinlog/921607253189_.pic.jpg" alt="921607253189_.pic"></p>
<h5 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a>什么是binlog</h5><ul>
<li><p>binlog是mysql server层特有的日志系统，称为mysql的归档日志，采用“追加写”的方式来记录操作日志。</p>
</li>
<li><p>binlog有固定的大小，超过这个大小会新启一个binglog文件来记录。</p>
</li>
<li><p>binlog记录的是逻辑操作，记录的是将username=’lulu’的age修改为16，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><ul>
<li><p>什么是两阶段提交？</p>
<p>mysql将redolog的写入拆分成两个步骤，用不同的状态来标识，一个是prepare状态，另一个是commit状态，这就是两阶段提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 对于如下sql</span><br><span class="line">update t set t.age &#x3D; 16 where a.username &#x3D; &#39;lulu&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行器从username的索引树上查找符合username=’lulu’的记录，回表取出age。</p>
</li>
<li><p>执行器拿到引擎给数据，将值更新为16，再调用接口写入数据。</p>
</li>
<li><p>引擎将这行数据更新到内存中（此时是写入到changebuffer或直接写入内存，详情请见<a href="http://www.alualu.cn/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/#more">普通索引和唯一索引的区别-更新语句的区别</a>。），将这次的更新操作记录到redolog里面，此时redolog处于prepare状态。</p>
</li>
<li><p>生成此次更新的binlog，并将binlog写入磁盘。</p>
</li>
<li><p>执行器调用事务提交的接口，将刚刚写入的redolog的prepare状态修改为commit状态。</p>
</li>
</ul>
<h5 id="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"><a href="#为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？" class="headerlink" title="为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？"></a>为什么要两阶段提交，我先写redolog，后写binlog行吗？或者反过来呢？会有什么问题？</h5><ul>
<li><p>首先要解释的一点是：innodb采用redolog，是支持崩溃恢复的。</p>
</li>
<li><p>先写redolog，后写binlog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写redolog，commit。</span><br><span class="line">-- step3: 写binlog。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，此事务的redolog已经记录完成，数据依旧可以从redolog恢复（age=24）。</li>
<li>但由于redolog的状态是commit，mysql不会再触发写入binlog的过程。由于binlog缺失这部分的变更归档，后续使用binlog做数据恢复时lulu依旧是18岁。</li>
</ul>
</li>
</ul>
</li>
<li><p>先写binlog，再写redolog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 假定lulu的年龄是18。</span><br><span class="line">-- step1: 执行:update t set t.age &#x3D; 24 where a.username &#x3D; &#39;lulu&#39;;</span><br><span class="line">-- step2: 写binlog。</span><br><span class="line">-- step3: 写redolog，commit。</span><br><span class="line">-- step4: 提交事务。</span><br></pre></td></tr></table></figure>

<ul>
<li>上述操作，step2执行完，执行step3时发生了崩溃。<ul>
<li>首先，服务崩溃本次事务是没有提交成功的（age=18）。</li>
<li>在崩溃恢复时，由于redolog没有记录变更日志，所以此次事务无效。</li>
<li>但binlog多了这部分的归档，后续使用binlog做数据恢复是lulu变成了24岁。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
