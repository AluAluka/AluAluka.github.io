<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>（图）JOIN语句是怎么执行的</title>
    <url>/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一图读懂mysql JOIN语句的执行流程和优化策略。</p>
<a id="more"></a>

<p><img src="/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84.png" alt="JOIN语句是怎么执行的"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）order by语句执行原理及优化策略</title>
    <url>/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>mysql的order by 语句执行原理以及如何优化。</p>
<a id="more"></a>

<p><img src="/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/1.png" alt="order by是怎么工作的？"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我建立了索引，却还是这么慢？</title>
    <url>/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>针对这种疑问，有以下两种情况：</p>
<ol>
<li><strong>优化器没有使用索引。</strong></li>
<li><strong>查询写的不对。</strong></li>
</ol>
<a id="more"></a>

<hr>
<h6 id="优化器没有使用索引"><a href="#优化器没有使用索引" class="headerlink" title="优化器没有使用索引"></a>优化器没有使用索引</h6><ul>
<li>条件字段的函数操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a，cdate字段均存在普通索引。</span><br><span class="line">-- 执行如下sql：</span><br><span class="line">select count(*) from t where month(cdate) &#x3D; &#39;7&#39;;</span><br><span class="line">select * from t where a+1 &#x3D; 1000;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，字段类型为varhcar(32)</span><br><span class="line">select * from t where a &#x3D; 200;</span><br><span class="line">-- 这个sql，存在两个问题：</span><br><span class="line">-- 1.数据类型的转换规则？</span><br><span class="line">-- 答：执行以下select &quot;10&quot; &gt; 9 如果是将字符串转换为数字，则返回结果应该是1，反之为0。</span><br><span class="line">-- 2.为什么走数据类型转换，就走全表扫描？</span><br><span class="line">-- 如果是字符串转换为数字，则上述sql，在执行之前会被优化器处理为：</span><br><span class="line">select * from t where CAST(a AS signed int) &#x3D; 200;</span><br><span class="line">-- 结果：explain显示，type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>隐式字符集转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引，编码为utf8mb4</span><br><span class="line">-- 表t1中 a1字段存在普通索引 编码为utf8</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; t2.a</span><br><span class="line">-- 由于utf8mb4是utf8的超集，在执行之前会被优化器处理为：</span><br><span class="line">select t1.*,t2.* from t1 straight_join t2 on t1.a &#x3D; CONVERT(t2.a USING utf8mb4)</span><br><span class="line">-- 结果：explain显示，表t2的type为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器认为在索引字段上加函数会破坏索引查询的有序性，从而导致mysql查询时放弃索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>NULL值比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a is null;</span><br><span class="line">select * from t where a is not null;</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql在对列构建索引时，单列索引无法存储null值，复合索引无法存储全为null的值，这是因为，NULL值无法比较大小，违反了索引树构建时的有序性原则。同理：用null值比较时，不能走索引，只能全表扫描。</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀模糊的查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表t中 a字段存在普通索引</span><br><span class="line">select * from t where a like &#39;%reg&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;%reg%&#39;; -- 一定走全表扫描</span><br><span class="line">select * from t where a like &#39;reg%&#39;; -- 不一定走全表扫描，mysql会将（全表扫描）的查询消耗和（索引查询+回表）的查询消耗作比较，从而选择出更优的执行计划。</span><br><span class="line">-- 结果：explain结果显示，表t的TYPE为ALL走了全表扫描</span><br><span class="line">-- 结论：mysql优化器在执行此类查询时，不清楚关键字reg是从索引键值的第几个位置开始，所以会根据数据量大小来选择全索引扫描或者全表扫描。</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="查询写的不对。"><a href="#查询写的不对。" class="headerlink" title="查询写的不对。"></a>查询写的不对。</h6><ul>
<li>不合理的分页语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如下业务场景，表t中，存在id,a,b,c,d,e,f字段，有300万行数据，现在要将每一列的值导出至txt文件。</span><br><span class="line">-- A同学考虑到了两个问题：</span><br><span class="line">-- 1.如果没有索引，将会全表扫描，性能较差，也不能建立union_index(a,b,c,d,e,f)代价太高。</span><br><span class="line">-- 综合考虑后，他选择了列值区分度最高的b字段。</span><br><span class="line">-- 2.300万数据一次性加载到服务端，可能会导致服务端发生OOM，于是他想到了分页。</span><br><span class="line">-- 定义初始的pageNum&#x3D;5000，通过计算得到pageSize&#x3D;60;</span><br><span class="line">-- 执行如下sql:（重点关注查询，循环只是简写，并不符合语法要求）</span><br><span class="line">i int default 0;</span><br><span class="line">	while i &lt; 60 do</span><br><span class="line">		select a,b,c,d,e,f from t limit i*5000,5000;</span><br><span class="line">    set i &#x3D; i + 1;</span><br><span class="line">  end while;</span><br><span class="line">-- A同学发现，尽管加了索引，但随着i值的增大，查询还是变的越来越慢。。。</span><br><span class="line">-- explain结果显示，查询走了b字段的索引。那为什么还是会慢呢？</span><br><span class="line">-- 答案是：</span><br><span class="line">-- mysql在执行上述查询时，要先走索引b，一行一行的回表查出a,b,c,d,e,f，然后放弃掉小于i*5000的行。</span><br><span class="line">-- 这会随着i值的增大出现严重的性能问题。</span><br><span class="line">-- 优化办法：延迟关联</span><br><span class="line">select a,b,c,d,e,f from t join (select id from t limit i*5000,5000) t2 on t.id &#x3D; t2.id</span><br><span class="line">-- 由于索引树上的每个值都存在对应主键的值，不需要在回表查询，因此t2的每一行直接在索引树上就可以拿到，查询消耗很小。</span><br><span class="line">-- t2表与t表属于主键关联，优化器在计算驱动表和被驱动表时，会优先将小表做驱动表，大表做被驱动表。</span><br><span class="line">-- 优化器预估t表需要扫描至少3000000行，而t2需要扫描只有5000行。</span><br><span class="line">-- 所以选择：t2表是驱动表，t表是被驱动表</span><br><span class="line">-- 上述查询的逻辑是从t2表中取id字段，去t表中查找主键id匹配的行，直接返回结果。</span><br><span class="line">-- 每次循环共计进行一次索引树扫描，扫描t表5000行。</span><br><span class="line">-- 查询自然很快啦~~~</span><br></pre></td></tr></table></figure>

<ul>
<li>关联子查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where t.a in (select a from t2 where t2.b&#x3D;&#39;c&#39;);</span><br><span class="line">-- mysql5.5之前的版本总是会将上述的in语句优化成如下sql</span><br><span class="line">select * from t where exists (select * from t2 where t2.a &#x3D; t.a and t2.b &#x3D; &#39;c&#39;);</span><br><span class="line">-- 首先解释一下in和exists的执行计划上的区别，抛开优化器将in优化成exists这个不谈(因为mysql5.6以后对in的优化策略有变动)。</span><br><span class="line">-- in语句，mysql优化器会先执行in中的subQuery，将返回的结果集做排序。（符合MRR优化），再去做全表扫描或者索引扫描。</span><br><span class="line">-- exists，mysql先从outerQuery取出一行，去subQuery做等值查询，如此循环直到outQuery循环完最后一行。</span><br><span class="line">-- exists和in的查询效率相同吗？得分情况讨论。</span><br><span class="line">-- t表是大表 t2是小表  in 更快</span><br><span class="line">-- t表时小表 t2是大表  exists 更快</span><br><span class="line">-- 所以在上述任何一个query返回比较慢的时候，决定优化query前，先考虑两张表在业务上，哪张表的数据量较大。</span><br><span class="line">-- 或者选用join来改写上述query，mysql优化器会正确预估驱动表和被驱动表(但需要确定改写成join后不会返回额外的重复记录)。</span><br><span class="line">select t.* from t join t2 on t.a &#x3D; t2.a where t2.b &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>性能提升利器-查询优化</title>
    <url>/2020/12/02/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%88%A9%E5%99%A8-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h5 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h5><h6 id="什么情况下应该建立索引"><a href="#什么情况下应该建立索引" class="headerlink" title="什么情况下应该建立索引"></a>什么情况下应该建立索引</h6><ol>
<li><p>首先考虑的是建立索引的成本是否可以接受：因为索引本身会占用一定的磁盘空间，如果mysql数据量特别大，建立索引，对查询的执行效率没有太大的提升，但构建索引会耗费更多的磁盘空间，还会在mysql服务器在执行DML操作时需要额外维护一次索引树，影响DML操作的执行效率，对于数据量特别大的表，建议采用分区表。</p>
</li>
<li><p>好，现在建立索引的成本可以接受了，次要考虑的是，索引列的区分度是否较大，对于一些列（比方说：性别，是否删除），这种区分度不大的列，建立索引其实效果很一般。</p>
</li>
<li><p>在where、join、exists中等值匹配的字段。</p>
</li>
<li><p>order by的字段。（这里没办法一句话讲清楚，详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a>）</p>
<a id="more"></a>

</li>
</ol>
<h6 id="该建立什么索引"><a href="#该建立什么索引" class="headerlink" title="该建立什么索引"></a>该建立什么索引</h6><p>上述情况都考虑过后，留给我们的问题就是建立什么样的索引：</p>
<ul>
<li><p>普通索引和唯一索引选哪个？：</p>
</li>
<li><p>详情请见<a href="http://www.alualu.cn/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/#more">普通索引和唯一索引的区别</a></p>
</li>
<li><p>该建立多个普通索引，还是一个联合索引？</p>
<ul>
<li><p>联合索引总是遵循<font color="red">最左前缀原则</font>：即对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where b &#x3D; &#39;123&#39;;  -- 无法使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，可以直接在索引上返回结果<font color="red">（mysql5.6引入的索引下推优化）</font>，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t;  -- 可以使用union_idx_abc(a,b,c)</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39;;  -- 可以使用union_idx_abc(a,b,c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于被联合索引覆盖的查询字段，当在这些字段上需要排序时，可以利用索引的有序性特点，直接在索引上返回排序结果，不需要回表查询，对于联合索引union_idx_abc(a,b,c)而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t order by b; </span><br><span class="line">-- 可以使用union_idx_abc(a,b,c) order b中，b列可以由a,b,c列任意单列或组合替换。</span><br><span class="line">select a,b,c from t where a &#x3D; &#39;123&#39; order by b;</span><br></pre></td></tr></table></figure>

<p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
</li>
</ul>
</li>
</ul>
<h6 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/JOIN%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/#more">一条JOIN语句时怎么执行的</a></p>
<h6 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h6><ul>
<li><p>in 语句优化</p>
<ul>
<li>in语句子查询会导致外层表无法使用索引。详见<a href="https://www.cnblogs.com/wy123/p/7092194.html"><a href="https://www.cnblogs.com/wy123/p/7092194.html">MySQL中IN子查询会导致无法使用索引</a></a></li>
<li>避免in语句的子查询不会返回过多的结果，否则影响查询效率。</li>
<li>尽量将in转化为join，前提是不会产生笛卡尔积。</li>
</ul>
</li>
<li><p>exists语句优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c from t where exists (select &#39;x&#39; from t2 where t.a &#x3D; t2.a)</span><br></pre></td></tr></table></figure>

<ul>
<li>当出现查询缓慢时，检查t2表的a字段是否存在索引。</li>
<li>t表数据量大时，尽量不要采取此写法，此查询会对t表进行全表或索引扫描，取出t表的每一行的a字段，与t2表的a字段做等值匹配。</li>
</ul>
</li>
</ul>
<h6 id="优化ORDER-BY"><a href="#优化ORDER-BY" class="headerlink" title="优化ORDER BY"></a>优化ORDER BY</h6><p>详情请见<a href="http://www.alualu.cn/2020/11/29/order-by%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/#more">order by语句执行原理及优化策略</a></p>
<h6 id="优化LIMIT"><a href="#优化LIMIT" class="headerlink" title="优化LIMIT"></a>优化LIMIT</h6><ul>
<li>是否能使用上覆盖索引<ul>
<li>通常情况下，limit语句首先要考虑的是能否使用覆盖索引，而不是查询所有的列。</li>
</ul>
</li>
<li>偏移量很大时，建议采取延迟关联<ul>
<li>详情请见<a href="http://www.alualu.cn/2020/11/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%B4%E8%BF%98%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/#more">为什么我建了索引，却还是那么慢？</a>中不合理的分页语句一栏。</li>
</ul>
</li>
</ul>
<h6 id="UNION-还是UNION-ALL"><a href="#UNION-还是UNION-ALL" class="headerlink" title="UNION 还是UNION ALL?"></a>UNION 还是UNION ALL?</h6><ul>
<li><p>如何优化</p>
<ul>
<li>mysql总是将UNION [ALL]的结果集放入一张临时表中，导致很多优化策略都没办法使用，通常情况下我们需要将where、limit、order by等语句下推到UNON [ALL]的子查询中，以便优化器能充分的利用这些条件来优化查询。</li>
</ul>
</li>
<li><p>UNION和UNION ALL的区别</p>
<ul>
<li>UNION：mysql将UNION左右的查询全部放入一张临时表中，然后使用DISTINCT对临时表做唯一性检查，确保唯一性的情况下将数据行返回给客户端。</li>
<li>UNION ALL ：mysql将UNION左右的查询全部放入一张临时表中，然后返回给客户端。</li>
</ul>
</li>
<li><p>UNION和UNION ALL，我该选哪个？</p>
<ul>
<li>除非客户端需要返回去重的数据，否则一定要使用UNION ALL</li>
</ul>
</li>
</ul>
<h6 id="优化COUNT"><a href="#优化COUNT" class="headerlink" title="优化COUNT"></a>优化COUNT</h6><ul>
<li>COUNT(id)，COUNT(1)，COUNT(字段)，COUNT(*)，我该选哪个？<ul>
<li>COUNT(id)：mysql会遍历整张表，将主键id的值取出来，返回给server层，server判断不可能为空，逐行累加。</li>
<li>COUNT(1)：server对返回的每一行数据，记录一个数字“1”进去，判断数字“1”不可能为空，逐行累加。</li>
<li>COUNT(字段)：如果字段定义not null，mysql遍历整张表，将该字段取出来，判断该字段不可能为null，逐行累加；如果字段定义允许为null，mysql还要额外将<font color="red">字段的值</font>取出来，判断如果不是NULL才累加。</li>
<li>COUNT(<em>)：mysql对COUNT(\</em>)做了专门的优化，*并不是取出表的所有字段，不需要取值，COUNT(*)肯定不是NULL，直接逐行累加。</li>
</ul>
</li>
<li>上述4种COUNT哪个快？<ul>
<li>按执行效率而言，COUNT(*)≈COUNT(1)&gt;COUNT(id)&gt;COUNT(字段)。</li>
<li>如果没有特殊的业务需求，建议采用COUNT(*)。</li>
</ul>
</li>
<li>我采用了COUNT(*)，但表太大还是很慢怎么办？<ul>
<li>建议单独建立计数器表，记录表名和表记录数，执行关于被记录表的DML语句时，在同一个事务内，对该计数器表进行更新（+1 or  -1）。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>（图）普通索引和唯一索引的区别</title>
    <url>/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>整理一下mysql普通索引和唯一索引的区别。</p>
<a id="more"></a>

<p><img src="/2020/11/27/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB-6659675.png" alt="普通索引和唯一索引的区别"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
